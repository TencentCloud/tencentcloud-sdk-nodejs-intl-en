/*
 * Copyright (c) 2018 THL A29 Limited, a Tencent company. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const AbstractModel = require("../../common/abstract_model");

/**
 * UploadLog response structure.
 * @class
 */
class UploadLogResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateAlarm response structure.
 * @class
 */
class CreateAlarmResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm policy ID.
         * @type {string || null}
         */
        this.AlarmId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmId = 'AlarmId' in params ? params.AlarmId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Alarm policy description
 * @class
 */
class AlarmInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm policy name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Monitoring object list
         * @type {Array.<AlarmTargetInfo> || null}
         */
        this.AlarmTargets = null;

        /**
         * Monitoring task running time point
         * @type {MonitorTime || null}
         */
        this.MonitorTime = null;

        /**
         * Single trigger condition. Mutually exclusive with the MultiConditions parameter.
         * @type {string || null}
         */
        this.Condition = null;

        /**
         * Alarm persistence cycle. An alarm will be triggered only after the corresponding trigger condition is met for the number of times specified by `TriggerCount`. Value range: 1–10.
         * @type {number || null}
         */
        this.TriggerCount = null;

        /**
         * Repeated alarm interval in minutes. Value range: 0–1440.
         * @type {number || null}
         */
        this.AlarmPeriod = null;

        /**
         * List of associated alarm notification templates
         * @type {Array.<string> || null}
         */
        this.AlarmNoticeIds = null;

        /**
         * Enablement status
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Alarm policy ID
         * @type {string || null}
         */
        this.AlarmId = null;

        /**
         * Creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Last update time
         * @type {string || null}
         */
        this.UpdateTime = null;

        /**
         * Custom notification template
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.MessageTemplate = null;

        /**
         * Custom callback template
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {CallBackInfo || null}
         */
        this.CallBack = null;

        /**
         * Multi-Dimensional analysis settings
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<AnalysisDimensional> || null}
         */
        this.Analysis = null;

        /**
         * Group trigger status. 1: Enabled, 0: Disabled (default)
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.GroupTriggerStatus = null;

        /**
         * Group Trigger ConditionsNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.GroupTriggerCondition = null;

        /**
         * Type of the monitored object. 0: common monitoring objects for execution statements; 1: separately selected monitoring objects for each execution statement.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.MonitorObjectType = null;

        /**
         * Alarm severity. 0: warning (Warn); 1: Reminder (Info); 2: urgent (Critical).Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.AlarmLevel = null;

        /**
         * Multiple trigger conditions. Exclusive with Condition.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<MultiCondition> || null}
         */
        this.MultiConditions = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;

        if (params.AlarmTargets) {
            this.AlarmTargets = new Array();
            for (let z in params.AlarmTargets) {
                let obj = new AlarmTargetInfo();
                obj.deserialize(params.AlarmTargets[z]);
                this.AlarmTargets.push(obj);
            }
        }

        if (params.MonitorTime) {
            let obj = new MonitorTime();
            obj.deserialize(params.MonitorTime)
            this.MonitorTime = obj;
        }
        this.Condition = 'Condition' in params ? params.Condition : null;
        this.TriggerCount = 'TriggerCount' in params ? params.TriggerCount : null;
        this.AlarmPeriod = 'AlarmPeriod' in params ? params.AlarmPeriod : null;
        this.AlarmNoticeIds = 'AlarmNoticeIds' in params ? params.AlarmNoticeIds : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.AlarmId = 'AlarmId' in params ? params.AlarmId : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;
        this.MessageTemplate = 'MessageTemplate' in params ? params.MessageTemplate : null;

        if (params.CallBack) {
            let obj = new CallBackInfo();
            obj.deserialize(params.CallBack)
            this.CallBack = obj;
        }

        if (params.Analysis) {
            this.Analysis = new Array();
            for (let z in params.Analysis) {
                let obj = new AnalysisDimensional();
                obj.deserialize(params.Analysis[z]);
                this.Analysis.push(obj);
            }
        }
        this.GroupTriggerStatus = 'GroupTriggerStatus' in params ? params.GroupTriggerStatus : null;
        this.GroupTriggerCondition = 'GroupTriggerCondition' in params ? params.GroupTriggerCondition : null;
        this.MonitorObjectType = 'MonitorObjectType' in params ? params.MonitorObjectType : null;
        this.AlarmLevel = 'AlarmLevel' in params ? params.AlarmLevel : null;

        if (params.MultiConditions) {
            this.MultiConditions = new Array();
            for (let z in params.MultiConditions) {
                let obj = new MultiCondition();
                obj.deserialize(params.MultiConditions[z]);
                this.MultiConditions.push(obj);
            }
        }

    }
}

/**
 * Log result information
 * @class
 */
class LogInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log time in milliseconds
         * @type {number || null}
         */
        this.Time = null;

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Log topic name
         * @type {string || null}
         */
        this.TopicName = null;

        /**
         * Log source IP
         * @type {string || null}
         */
        this.Source = null;

        /**
         * Log filename
         * @type {string || null}
         */
        this.FileName = null;

        /**
         * ID of the request package for log reporting
         * @type {string || null}
         */
        this.PkgId = null;

        /**
         * Log ID in request package
         * @type {string || null}
         */
        this.PkgLogId = null;

        /**
         * Serialized JSON string of log content
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogJson = null;

        /**
         * Source host name of logs
Note: This field may return `null`, indicating that no valid value was found.
         * @type {string || null}
         */
        this.HostName = null;

        /**
         * Raw log (this parameter has a value only when an exception occurred while creating indexes for logs).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.RawLog = null;

        /**
         * The cause of index creation exception (this parameter has a value only when an exception occurred while creating indexes for logs).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.IndexStatus = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Time = 'Time' in params ? params.Time : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.TopicName = 'TopicName' in params ? params.TopicName : null;
        this.Source = 'Source' in params ? params.Source : null;
        this.FileName = 'FileName' in params ? params.FileName : null;
        this.PkgId = 'PkgId' in params ? params.PkgId : null;
        this.PkgLogId = 'PkgLogId' in params ? params.PkgLogId : null;
        this.LogJson = 'LogJson' in params ? params.LogJson : null;
        this.HostName = 'HostName' in params ? params.HostName : null;
        this.RawLog = 'RawLog' in params ? params.RawLog : null;
        this.IndexStatus = 'IndexStatus' in params ? params.IndexStatus : null;

    }
}

/**
 * DeleteAlarmNotice response structure.
 * @class
 */
class DeleteAlarmNoticeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeLogHistogram request structure.
 * @class
 */
class DescribeLogHistogramRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Start time of the log to be queried, which is a Unix timestamp in milliseconds
         * @type {number || null}
         */
        this.From = null;

        /**
         * End time of the log to be queried, which is a Unix timestamp in milliseconds
         * @type {number || null}
         */
        this.To = null;

        /**
         * Query statement
         * @type {string || null}
         */
        this.Query = null;

        /**
         * ID of the log topic to be queried
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Interval in milliseconds. Condition: (To-From) / Interval <= 200
         * @type {number || null}
         */
        this.Interval = null;

        /**
         * Search syntax. Valid values:
`0` (default): Lucene; `1`: CQL
For more information, see <a href="https://intl.cloud.tencent.com/document/product/614/47044?from_cn_redirect=1#RetrievesConditionalRules" target="_blank">Search Syntax</a>.
         * @type {number || null}
         */
        this.SyntaxRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.From = 'From' in params ? params.From : null;
        this.To = 'To' in params ? params.To : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Interval = 'Interval' in params ? params.Interval : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;

    }
}

/**
 * DeleteAlarmShield request structure.
 * @class
 */
class DeleteAlarmShieldRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Blocking rule ID.
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Notification channel group ID.
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;

    }
}

/**
 * DescribeLogContext request structure.
 * @class
 */
class DescribeLogContextRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID to be queried
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Log time in the format of YYYY-mm-dd HH:MM:SS.FFF
         * @type {string || null}
         */
        this.BTime = null;

        /**
         * Log package sequence number. PkgId in the Results structure of the returned information of SearchLog API.
         * @type {string || null}
         */
        this.PkgId = null;

        /**
         * Sequence number of a log within the log package.
The PkgLogId in the Results structure of the SearchLog API returned information.
         * @type {number || null}
         */
        this.PkgLogId = null;

        /**
         * The previous ${PrevLogs} logs. Default value: 10.
         * @type {number || null}
         */
        this.PrevLogs = null;

        /**
         * The next ${NextLogs} logs. Default value: 10.
         * @type {number || null}
         */
        this.NextLogs = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.BTime = 'BTime' in params ? params.BTime : null;
        this.PkgId = 'PkgId' in params ? params.PkgId : null;
        this.PkgLogId = 'PkgLogId' in params ? params.PkgLogId : null;
        this.PrevLogs = 'PrevLogs' in params ? params.PrevLogs : null;
        this.NextLogs = 'NextLogs' in params ? params.NextLogs : null;

    }
}

/**
 * DeleteShipper request structure.
 * @class
 */
class DeleteShipperRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping rule ID
         * @type {string || null}
         */
        this.ShipperId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ShipperId = 'ShipperId' in params ? params.ShipperId : null;

    }
}

/**
 * DeleteScheduledSql request structure.
 * @class
 */
class DeleteScheduledSqlRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Task ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Source Log Topic ID
         * @type {string || null}
         */
        this.SrcTopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.SrcTopicId = 'SrcTopicId' in params ? params.SrcTopicId : null;

    }
}

/**
 * Key-value index auto-configuration enables automatic addition of fields from logs into the key-value index, including subsequently added fields in the logs.
 * @class
 */
class DynamicIndex extends  AbstractModel {
    constructor(){
        super();

        /**
         * Key-Value Index Auto-Config Switch
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.Status = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Status = 'Status' in params ? params.Status : null;

    }
}

/**
 * DeleteLogset response structure.
 * @class
 */
class DeleteLogsetResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * `Parquet` content description
 * @class
 */
class ParquetKeyInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Key name
         * @type {string || null}
         */
        this.KeyName = null;

        /**
         * Supported data types: string, boolean, int32, int64, float, and double
         * @type {string || null}
         */
        this.KeyType = null;

        /**
         * Assignment information returned upon resolution failure
Note: This field may return `null`, indicating that no valid value can be obtained.
         * @type {string || null}
         */
        this.KeyNonExistingField = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.KeyName = 'KeyName' in params ? params.KeyName : null;
        this.KeyType = 'KeyType' in params ? params.KeyType : null;
        this.KeyNonExistingField = 'KeyNonExistingField' in params ? params.KeyNonExistingField : null;

    }
}

/**
 * DescribeCosRecharges response structure.
 * @class
 */
class DescribeCosRechargesResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * See the description of the `CosRechargeInfo` structure.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<CosRechargeInfo> || null}
         */
        this.Data = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Data) {
            this.Data = new Array();
            for (let z in params.Data) {
                let obj = new CosRechargeInfo();
                obj.deserialize(params.Data[z]);
                this.Data.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeShipperTasks response structure.
 * @class
 */
class DescribeShipperTasksResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping task list
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<ShipperTaskInfo> || null}
         */
        this.Tasks = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Tasks) {
            this.Tasks = new Array();
            for (let z in params.Tasks) {
                let obj = new ShipperTaskInfo();
                obj.deserialize(params.Tasks[z]);
                this.Tasks.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CheckFunction request structure.
 * @class
 */
class CheckFunctionRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Processing statement entered by the user
         * @type {string || null}
         */
        this.EtlContent = null;

        /**
         * Target topic ID and alias of the data processing task
         * @type {Array.<DataTransformResouceInfo> || null}
         */
        this.DstResources = null;

        /**
         * Type of the target topic for data processing. Valid values: 1 (fixed Topic) and 2 (dynamic creation)
         * @type {number || null}
         */
        this.FuncType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.EtlContent = 'EtlContent' in params ? params.EtlContent : null;

        if (params.DstResources) {
            this.DstResources = new Array();
            for (let z in params.DstResources) {
                let obj = new DataTransformResouceInfo();
                obj.deserialize(params.DstResources[z]);
                this.DstResources.push(obj);
            }
        }
        this.FuncType = 'FuncType' in params ? params.FuncType : null;

    }
}

/**
 * Filter
 * @class
 */
class Filter extends  AbstractModel {
    constructor(){
        super();

        /**
         * Field to be filtered
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Value to be filtered
         * @type {Array.<string> || null}
         */
        this.Values = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Values = 'Values' in params ? params.Values : null;

    }
}

/**
 * DescribeAlarmShields response structure.
 * @class
 */
class DescribeAlarmShieldsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The total number of rules that meet the criteria
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * Details of the alarm blocking rules
         * @type {Array.<AlarmShieldInfo> || null}
         */
        this.AlarmShields = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;

        if (params.AlarmShields) {
            this.AlarmShields = new Array();
            for (let z in params.AlarmShields) {
                let obj = new AlarmShieldInfo();
                obj.deserialize(params.AlarmShields[z]);
                this.AlarmShields.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * SearchCosRechargeInfo request structure.
 * @class
 */
class SearchCosRechargeInfoRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Delivery Task Name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * COS bucket, see the supported [bucket naming conventions](https://intl.cloud.tencent.com/document/product/436/13312?from_cn_redirect=1).
         * @type {string || null}
         */
        this.Bucket = null;

        /**
         * The region where the COS bucket is located, see the supported [region list](https://intl.cloud.tencent.com/document/product/436/6224?from_cn_redirect=1).
         * @type {string || null}
         */
        this.BucketRegion = null;

        /**
         * The prefix of the folder where COS files are located
         * @type {string || null}
         */
        this.Prefix = null;

        /**
         * Compression mode: "", "gzip", "lzop", and "snappy". The default mode is "".
         * @type {string || null}
         */
        this.Compress = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.Bucket = 'Bucket' in params ? params.Bucket : null;
        this.BucketRegion = 'BucketRegion' in params ? params.BucketRegion : null;
        this.Prefix = 'Prefix' in params ? params.Prefix : null;
        this.Compress = 'Compress' in params ? params.Compress : null;

    }
}

/**
 * Kafka data import configuration
 * @class
 */
class KafkaRechargeInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * ID of the Kafka data subscription configuration.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Id = null;

        /**
         * Log topic ID
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Kafka data import task name
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Kafka type. Valid values: 0 (Tencent Cloud CKafka) and 1 (customer's Kafka).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.KafkaType = null;

        /**
         * CKafka instance ID, which is required when `KafkaType` is set to `0`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.KafkaInstance = null;

        /**
         * Service address
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.ServerAddr = null;

        /**
         * Whether the service address uses an encrypted connection	
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.IsEncryptionAddr = null;

        /**
         * Encryption access protocol, which is required when `IsEncryptionAddr` is set to `true`
         * @type {KafkaProtocolInfo || null}
         */
        this.Protocol = null;

        /**
         * List of Kafka topics to import data from. Separate multiple topics with commas (,).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UserKafkaTopics = null;

        /**
         * Kafka consumer group name	
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.ConsumerGroupName = null;

        /**
         * Status, 1: running; 2: paused.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Import data position, -2: earliest (default), -1: latestNote: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Creation time
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Update time
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UpdateTime = null;

        /**
         * Log import rule
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {LogRechargeRuleInfo || null}
         */
        this.LogRechargeRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Id = 'Id' in params ? params.Id : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.KafkaType = 'KafkaType' in params ? params.KafkaType : null;
        this.KafkaInstance = 'KafkaInstance' in params ? params.KafkaInstance : null;
        this.ServerAddr = 'ServerAddr' in params ? params.ServerAddr : null;
        this.IsEncryptionAddr = 'IsEncryptionAddr' in params ? params.IsEncryptionAddr : null;

        if (params.Protocol) {
            let obj = new KafkaProtocolInfo();
            obj.deserialize(params.Protocol)
            this.Protocol = obj;
        }
        this.UserKafkaTopics = 'UserKafkaTopics' in params ? params.UserKafkaTopics : null;
        this.ConsumerGroupName = 'ConsumerGroupName' in params ? params.ConsumerGroupName : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;

        if (params.LogRechargeRule) {
            let obj = new LogRechargeRuleInfo();
            obj.deserialize(params.LogRechargeRule)
            this.LogRechargeRule = obj;
        }

    }
}

/**
 * ModifyLogset request structure.
 * @class
 */
class ModifyLogsetRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Logset name
         * @type {string || null}
         */
        this.LogsetName = null;

        /**
         * Tag key-value pair bound to logset. Up to 10 tag key-value pairs are supported, and a resource can be bound to only one tag key at any time.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.LogsetName = 'LogsetName' in params ? params.LogsetName : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }

    }
}

/**
 * UploadLog request structure.
 * @class
 */
class UploadLogRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Topic partition where data will be written into by `HashKey` 
         * @type {string || null}
         */
        this.HashKey = null;

        /**
         * Compression type
         * @type {string || null}
         */
        this.CompressType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.HashKey = 'HashKey' in params ? params.HashKey : null;
        this.CompressType = 'CompressType' in params ? params.CompressType : null;

    }
}

/**
 * CreateLogset request structure.
 * @class
 */
class CreateLogsetRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset name, which must be unique
         * @type {string || null}
         */
        this.LogsetName = null;

        /**
         * Tag description list. Up to 10 tag key-value pairs are supported and must be unique.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetName = 'LogsetName' in params ? params.LogsetName : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }

    }
}

/**
 * DescribeShippers request structure.
 * @class
 */
class DescribeShippersRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * - shipperName: Filter by **shipping rule name**. Type: String. Required: No.
- shipperId: Filter by **shipping rule ID**. Type: String. Required: No.
- topicId: Filter by **log topic**. Type: String. Required: No.

Each request can have up to 10 `Filters` and 100 `Filter.Values`.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * CreateScheduledSql response structure.
 * @class
 */
class CreateScheduledSqlResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Task ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * QueryMetric request structure.
 * @class
 */
class QueryMetricRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Query statement, using PromQL syntax	
         * @type {string || null}
         */
        this.Query = null;

        /**
         * Metric Topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Query time, Unix Timestamp in seconds	
         * @type {number || null}
         */
        this.Time = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Query = 'Query' in params ? params.Query : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Time = 'Time' in params ? params.Time : null;

    }
}

/**
 * Key-Value pair in log
 * @class
 */
class LogItem extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log key
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Log value
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * SearchLog response structure.
 * @class
 */
class SearchLogResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Pass through the Context value returned by this API, which can access more logs later, with an expiration time of 1 hour.Note:* Applicable only for single log topic searches. When searching multiple log topics, please use the Context in Topics.
         * @type {string || null}
         */
        this.Context = null;

        /**
         * Whether to return all raw log query results. If not, you can use `Context` to continue to get logs.
Note: This parameter is valid only when the query statement (`Query`) does not contain an SQL statement.
         * @type {boolean || null}
         */
        this.ListOver = null;

        /**
         * Whether the returned data is the analysis (SQL) result
         * @type {boolean || null}
         */
        this.Analysis = null;

        /**
         * Raw logs that meet the search conditions
Note: This field may return `null`, indicating that no valid value was found.
         * @type {Array.<LogInfo> || null}
         */
        this.Results = null;

        /**
         * Column names of log analysis
This parameter is valid only when `UseNewAnalysis` is `false`.
Note: This field may return `null`, indicating that no valid value was found.
         * @type {Array.<string> || null}
         */
        this.ColNames = null;

        /**
         * Log analysis result
This parameter is valid only when `UseNewAnalysis` is `false`.
Note: This field may return `null`, indicating that no valid value was found.
         * @type {Array.<LogItems> || null}
         */
        this.AnalysisResults = null;

        /**
         * Log analysis result
This parameter is valid only when `UseNewAnalysis` is `true`.
Note: This field may return `null`, indicating that no valid value was found.
         * @type {Array.<string> || null}
         */
        this.AnalysisRecords = null;

        /**
         * Column attributes of log analysis
This parameter is valid only when `UseNewAnalysis` is `true`.
Note: This field may return `null`, indicating that no valid value was found.
         * @type {Array.<Column> || null}
         */
        this.Columns = null;

        /**
         * Sample rate used in this statistical analysis
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.SamplingRate = null;

        /**
         * Refers to the basic information of each log topic when multiple log topics are used for search, such as error messages.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {SearchLogTopics || null}
         */
        this.Topics = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Context = 'Context' in params ? params.Context : null;
        this.ListOver = 'ListOver' in params ? params.ListOver : null;
        this.Analysis = 'Analysis' in params ? params.Analysis : null;

        if (params.Results) {
            this.Results = new Array();
            for (let z in params.Results) {
                let obj = new LogInfo();
                obj.deserialize(params.Results[z]);
                this.Results.push(obj);
            }
        }
        this.ColNames = 'ColNames' in params ? params.ColNames : null;

        if (params.AnalysisResults) {
            this.AnalysisResults = new Array();
            for (let z in params.AnalysisResults) {
                let obj = new LogItems();
                obj.deserialize(params.AnalysisResults[z]);
                this.AnalysisResults.push(obj);
            }
        }
        this.AnalysisRecords = 'AnalysisRecords' in params ? params.AnalysisRecords : null;

        if (params.Columns) {
            this.Columns = new Array();
            for (let z in params.Columns) {
                let obj = new Column();
                obj.deserialize(params.Columns[z]);
                this.Columns.push(obj);
            }
        }
        this.SamplingRate = 'SamplingRate' in params ? params.SamplingRate : null;

        if (params.Topics) {
            let obj = new SearchLogTopics();
            obj.deserialize(params.Topics)
            this.Topics = obj;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteTopic request structure.
 * @class
 */
class DeleteTopicRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

    }
}

/**
 * DescribePartitions request structure.
 * @class
 */
class DescribePartitionsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

    }
}

/**
 * Collection rule configuration information
 * @class
 */
class ConfigInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection rule configuration ID
         * @type {string || null}
         */
        this.ConfigId = null;

        /**
         * Name of the collection rule configuration
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Log formatting method
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogFormat = null;

        /**
         * Log collection path
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Path = null;

        /**
         * Type of collected logs.- json_log: JSON File Log (For more information, see [Using JSON pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17419?from_cn_redirect=1));- delimiter_log: Delimiter - File Logs (For more information, see [Using delimiter pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17420?from_cn_redirect=1));- minimalist_log: Single-line Full-text File Log (For more information, see [Using single-line full-text pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17421?from_cn_redirect=1));- fullregex_log: Single line full regular expression - File log (For more information, see [Using single-line - complete regular expression pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/52365?from_cn_redirect=1));- multiline_log: Multiline Full-text File Log (For more information, see [Using multi-line full-text pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17422?from_cn_redirect=1));- multiline_fullregex_log: Multi-line complete regular expression - File Logs (For more information, see [Using multi-line - complete regular expression pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/52366?from_cn_redirect=1));- user_define_log: Combined parsing (Suitable for logs with multiple nested formats, see [Using combined parsing pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/61310?from_cn_redirect=1));- service_syslog: syslog collection (For more information, see [Collect Syslog](https://intl.cloud.tencent.com/document/product/614/81454?from_cn_redirect=1));- windows_event_log represents: Windows event logs (see Collecting Windows Event Logs (https://intl.cloud.tencent.com/document/product/614/96678?from_cn_redirect=1) for details.).Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogType = null;

        /**
         * Extraction rule. If `ExtractRule` is set, `LogType` must be set
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {ExtractRuleInfo || null}
         */
        this.ExtractRule = null;

        /**
         * Collection path blocklist
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<ExcludePathInfo> || null}
         */
        this.ExcludePaths = null;

        /**
         * Log topic ID (TopicId) of collection configuration
         * @type {string || null}
         */
        this.Output = null;

        /**
         * Update time
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UpdateTime = null;

        /**
         * Creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * User-defined parsing strings, see Collecting Logs Using Combined Parsing Extraction Mode (https://intl.cloud.tencent.com/document/product/614/61310?from_cn_redirect=1) for details.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UserDefineRule = null;

        /**
         * Advanced collection configuration. A JSON string, Key/Value definition as follows:- ClsAgentFileTimeout (timeout property), value range: an integer greater than or equal to 0, where 0 means no timeout- ClsAgentMaxDepth (maximum directory depth), value range: an integer greater than or equal to 0- ClsAgentParseFailMerge (merge logs that failed parsing), value range: true or falseSample:`{\"ClsAgentFileTimeout\":0,\"ClsAgentMaxDepth\":10,\"ClsAgentParseFailMerge\":true}`

Default placeholder value in the console: `{"ClsAgentDefault":0}`Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.AdvancedConfig = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ConfigId = 'ConfigId' in params ? params.ConfigId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.LogFormat = 'LogFormat' in params ? params.LogFormat : null;
        this.Path = 'Path' in params ? params.Path : null;
        this.LogType = 'LogType' in params ? params.LogType : null;

        if (params.ExtractRule) {
            let obj = new ExtractRuleInfo();
            obj.deserialize(params.ExtractRule)
            this.ExtractRule = obj;
        }

        if (params.ExcludePaths) {
            this.ExcludePaths = new Array();
            for (let z in params.ExcludePaths) {
                let obj = new ExcludePathInfo();
                obj.deserialize(params.ExcludePaths[z]);
                this.ExcludePaths.push(obj);
            }
        }
        this.Output = 'Output' in params ? params.Output : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UserDefineRule = 'UserDefineRule' in params ? params.UserDefineRule : null;
        this.AdvancedConfig = 'AdvancedConfig' in params ? params.AdvancedConfig : null;

    }
}

/**
 * ModifyAlarm response structure.
 * @class
 */
class ModifyAlarmResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeShipperTasks request structure.
 * @class
 */
class DescribeShipperTasksRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping rule ID
         * @type {string || null}
         */
        this.ShipperId = null;

        /**
         * Query start timestamp in milliseconds, which can be within the last three days
         * @type {number || null}
         */
        this.StartTime = null;

        /**
         * Query end timestamp in milliseconds
         * @type {number || null}
         */
        this.EndTime = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ShipperId = 'ShipperId' in params ? params.ShipperId : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;

    }
}

/**
 * DescribeAlarms request structure.
 * @class
 */
class DescribeAlarmsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * name
- Filter by **alarm policy name**
- Type: String
- Required: No

alarmId
- Filter by **alarm policy ID**
- Type: String
- Required: No

topicId
- Filter by **log topic ID**
- Type: String
- Required: No

enable
- Filter by **enablement status**
- Type: String
- Note: The valid values of `enable` include `1`, `t`, `T`, `TRUE`, `true`, `True`, `0`, `f`, `F`, `FALSE`, `false`, and `False`. If other values are entered, an "invalid parameter" error will be returned.
- Required: No

Each request can contain up to 10 `Filters` and 5 `Filter.Values`.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100.
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * MergePartition request structure.
 * @class
 */
class MergePartitionRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Merged `PartitionId`
         * @type {number || null}
         */
        this.PartitionId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.PartitionId = 'PartitionId' in params ? params.PartitionId : null;

    }
}

/**
 * DescribeShippers response structure.
 * @class
 */
class DescribeShippersResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping rule list
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<ShipperInfo> || null}
         */
        this.Shippers = null;

        /**
         * Total number of results obtained in this query
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Shippers) {
            this.Shippers = new Array();
            for (let z in params.Shippers) {
                let obj = new ShipperInfo();
                obj.deserialize(params.Shippers[z]);
                this.Shippers.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeKafkaConsumer response structure.
 * @class
 */
class DescribeKafkaConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Whether Kafka Protocol Consumption is enabled
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Topic Parameter used by KafkaConsumer during consumption
         * @type {string || null}
         */
        this.TopicID = null;

        /**
         * Compression mode [0: NONE; 2: SNAPPY; 3: LZ4]
         * @type {number || null}
         */
        this.Compression = null;

        /**
         * Kafka protocol consumer data format
         * @type {KafkaConsumerContent || null}
         */
        this.ConsumerContent = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Status = 'Status' in params ? params.Status : null;
        this.TopicID = 'TopicID' in params ? params.TopicID : null;
        this.Compression = 'Compression' in params ? params.Compression : null;

        if (params.ConsumerContent) {
            let obj = new KafkaConsumerContent();
            obj.deserialize(params.ConsumerContent)
            this.ConsumerContent = obj;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyShipper response structure.
 * @class
 */
class ModifyShipperResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteKafkaRecharge response structure.
 * @class
 */
class DeleteKafkaRechargeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyDataTransform request structure.
 * @class
 */
class ModifyDataTransformRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Data processing task ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Data processing task name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Data processing statement
         * @type {string || null}
         */
        this.EtlContent = null;

        /**
         * Task status. Valid values: 1 (enabled) and 2 (disabled).
         * @type {number || null}
         */
        this.EnableFlag = null;

        /**
         * Destination topic ID and alias of the data processing task
         * @type {Array.<DataTransformResouceInfo> || null}
         */
        this.DstResources = null;

        /**
         * Whether to enable delivery service log. 1 for disabled, 2 for enabled
         * @type {number || null}
         */
        this.HasServicesLog = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.EtlContent = 'EtlContent' in params ? params.EtlContent : null;
        this.EnableFlag = 'EnableFlag' in params ? params.EnableFlag : null;

        if (params.DstResources) {
            this.DstResources = new Array();
            for (let z in params.DstResources) {
                let obj = new DataTransformResouceInfo();
                obj.deserialize(params.DstResources[z]);
                this.DstResources.push(obj);
            }
        }
        this.HasServicesLog = 'HasServicesLog' in params ? params.HasServicesLog : null;

    }
}

/**
 * DescribeScheduledSqlInfo response structure.
 * @class
 */
class DescribeScheduledSqlInfoResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Scheduled SQL Task List Information
         * @type {Array.<ScheduledSqlTaskInfo> || null}
         */
        this.ScheduledSqlTaskInfos = null;

        /**
         * Total number of tasks
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.ScheduledSqlTaskInfos) {
            this.ScheduledSqlTaskInfos = new Array();
            for (let z in params.ScheduledSqlTaskInfos) {
                let obj = new ScheduledSqlTaskInfo();
                obj.deserialize(params.ScheduledSqlTaskInfos[z]);
                this.ScheduledSqlTaskInfos.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Callback configuration
 * @class
 */
class CallBackInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * `Body` during callback
         * @type {string || null}
         */
        this.Body = null;

        /**
         * `Headers` during callback
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.Headers = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Body = 'Body' in params ? params.Body : null;
        this.Headers = 'Headers' in params ? params.Headers : null;

    }
}

/**
 * OpenKafkaConsumer response structure.
 * @class
 */
class OpenKafkaConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Topic Parameter used by KafkaConsumer during consumption
         * @type {string || null}
         */
        this.TopicID = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicID = 'TopicID' in params ? params.TopicID : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Alarm object
 * @class
 */
class AlarmTargetInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Logset name
         * @type {string || null}
         */
        this.LogsetName = null;

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Log topic name
         * @type {string || null}
         */
        this.TopicName = null;

        /**
         * Query statement
         * @type {string || null}
         */
        this.Query = null;

        /**
         * Monitoring object number
         * @type {number || null}
         */
        this.Number = null;

        /**
         * Offset of the query start time from the alarm execution time in minutes. The value cannot be positive. Value range: -1440–0.
         * @type {number || null}
         */
        this.StartTimeOffset = null;

        /**
         * Offset of the query end time from the alarm execution time in minutes. The value cannot be positive and must be greater than `StartTimeOffset`. Value range: -1440–0.
         * @type {number || null}
         */
        this.EndTimeOffset = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.LogsetName = 'LogsetName' in params ? params.LogsetName : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.TopicName = 'TopicName' in params ? params.TopicName : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.Number = 'Number' in params ? params.Number : null;
        this.StartTimeOffset = 'StartTimeOffset' in params ? params.StartTimeOffset : null;
        this.EndTimeOffset = 'EndTimeOffset' in params ? params.EndTimeOffset : null;

    }
}

/**
 * Alarm Classification Information
 * @class
 */
class AlarmClassification extends  AbstractModel {
    constructor(){
        super();

        /**
         * Classification Key
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Classification Value
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * Resource information for ScheduledSql
 * @class
 */
class ScheduledSqlResouceInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Target topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Region information for the topic
         * @type {string || null}
         */
        this.Region = null;

        /**
         * Topic type: 0 for log topic, and 1 for metric topic
         * @type {number || null}
         */
        this.BizType = null;

        /**
         * Metric name. When BizType is 1, MetricName needs to be specified.
         * @type {string || null}
         */
        this.MetricName = null;

        /**
         * Metric NameWhen BizType is 1, prioritize using the MetricNames field. Multiple metrics can only be filled in the MetricNames field, while it's recommended to fill a single metric in the MetricName field.
         * @type {Array.<string> || null}
         */
        this.MetricNames = null;

        /**
         * Metric dimension. Not accept time type.
         * @type {Array.<string> || null}
         */
        this.MetricLabels = null;

        /**
         * Metric timestamp. The default value is the left time point of the SQL query time range, but you can also specify other fields (The type is uinx time, TimeStamp, and precision millisecond) as the metric timestamp.
         * @type {string || null}
         */
        this.CustomTime = null;

        /**
         * In addition to MetricLabels, this parameter can be used to supplement static dimensions for the metric.
Dimension names must start with a letter or underscore, followed by letters, digits, or underscores, with a length less than or equal to 1024 bytes.
         * @type {Array.<MetricLabel> || null}
         */
        this.CustomMetricLabels = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Region = 'Region' in params ? params.Region : null;
        this.BizType = 'BizType' in params ? params.BizType : null;
        this.MetricName = 'MetricName' in params ? params.MetricName : null;
        this.MetricNames = 'MetricNames' in params ? params.MetricNames : null;
        this.MetricLabels = 'MetricLabels' in params ? params.MetricLabels : null;
        this.CustomTime = 'CustomTime' in params ? params.CustomTime : null;

        if (params.CustomMetricLabels) {
            this.CustomMetricLabels = new Array();
            for (let z in params.CustomMetricLabels) {
                let obj = new MetricLabel();
                obj.deserialize(params.CustomMetricLabels[z]);
                this.CustomMetricLabels.push(obj);
            }
        }

    }
}

/**
 * RetryShipperTask response structure.
 * @class
 */
class RetryShipperTaskResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeIndex request structure.
 * @class
 */
class DescribeIndexRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

    }
}

/**
 * ModifyScheduledSql response structure.
 * @class
 */
class ModifyScheduledSqlResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * 
 * @class
 */
class ConditionInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * 
         * @type {string || null}
         */
        this.Attributes = null;

        /**
         * 
         * @type {number || null}
         */
        this.Rule = null;

        /**
         * 
         * @type {string || null}
         */
        this.ConditionValue = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Attributes = 'Attributes' in params ? params.Attributes : null;
        this.Rule = 'Rule' in params ? params.Rule : null;
        this.ConditionValue = 'ConditionValue' in params ? params.ConditionValue : null;

    }
}

/**
 * DeleteMachineGroupInfo request structure.
 * @class
 */
class DeleteMachineGroupInfoRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

        /**
         * Machine group type
Supported types: `ip` and `label`
         * @type {MachineGroupTypeInfo || null}
         */
        this.MachineGroupType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;

        if (params.MachineGroupType) {
            let obj = new MachineGroupTypeInfo();
            obj.deserialize(params.MachineGroupType)
            this.MachineGroupType = obj;
        }

    }
}

/**
 * CreateLogset response structure.
 * @class
 */
class CreateLogsetResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Notification rules
 * @class
 */
class NoticeRule extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarms notification template recipient informationNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<NoticeReceiver> || null}
         */
        this.NoticeReceivers = null;

        /**
         * Alarms notification template callback informationNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<WebCallback> || null}
         */
        this.WebCallbacks = null;

        /**
         * Matching rules.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Rule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.NoticeReceivers) {
            this.NoticeReceivers = new Array();
            for (let z in params.NoticeReceivers) {
                let obj = new NoticeReceiver();
                obj.deserialize(params.NoticeReceivers[z]);
                this.NoticeReceivers.push(obj);
            }
        }

        if (params.WebCallbacks) {
            this.WebCallbacks = new Array();
            for (let z in params.WebCallbacks) {
                let obj = new WebCallback();
                obj.deserialize(params.WebCallbacks[z]);
                this.WebCallbacks.push(obj);
            }
        }
        this.Rule = 'Rule' in params ? params.Rule : null;

    }
}

/**
 * DeleteMachineGroup response structure.
 * @class
 */
class DeleteMachineGroupResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Kafka access protocol
 * @class
 */
class KafkaProtocolInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Protocol type, including plaintext, sasl_plaintext, or sasl_ssl. sasl_ssl is recommended for encrypted connections and user authentication.Required input parameters
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Protocol = null;

        /**
         * Encryption type, supports PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.Required when the Protocol is sasl_plaintext or sasl_ssl.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Mechanism = null;

        /**
         * UsernameRequired when the Protocol is sasl_plaintext or sasl_ssl.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UserName = null;

        /**
         * User PasswordRequired when the Protocol is sasl_plaintext or sasl_ssl.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Password = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Protocol = 'Protocol' in params ? params.Protocol : null;
        this.Mechanism = 'Mechanism' in params ? params.Mechanism : null;
        this.UserName = 'UserName' in params ? params.UserName : null;
        this.Password = 'Password' in params ? params.Password : null;

    }
}

/**
 * ScheduledSql task details
 * @class
 */
class ScheduledSqlTaskInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * ScheduledSql task id
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * ScheduledSql task name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Source Log Topic ID
         * @type {string || null}
         */
        this.SrcTopicId = null;

        /**
         * Source Log Topic Name
         * @type {string || null}
         */
        this.SrcTopicName = null;

        /**
         * Scheduled SQL analysis of target topic
         * @type {ScheduledSqlResouceInfo || null}
         */
        this.DstResource = null;

        /**
         * Creation Time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Task Update Time
         * @type {string || null}
         */
        this.UpdateTime = null;

        /**
         * Task status: 1: Running 2: Stop 3: Exception - Source log topic not found 4: Exception - target topic not found5: Access permission issue 6: Internal failure 7: Other faults
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Task status: 1 Enabled, 2 Disabled
         * @type {number || null}
         */
        this.EnableFlag = null;

        /**
         * Queries statements
         * @type {string || null}
         */
        this.ScheduledSqlContent = null;

        /**
         * Schedule Start Time
         * @type {string || null}
         */
        this.ProcessStartTime = null;

        /**
         * Schedule Type: 1 Continuous Running 2 Specified Time Range
         * @type {number || null}
         */
        this.ProcessType = null;

        /**
         * Schedule End Time, required when process_type=2
         * @type {string || null}
         */
        this.ProcessEndTime = null;

        /**
         * Scheduling Interval (Minutes)
         * @type {number || null}
         */
        this.ProcessPeriod = null;

        /**
         * Query Time Window. @m-15m, @m, meaning the last 15 minutes
         * @type {string || null}
         */
        this.ProcessTimeWindow = null;

        /**
         * Execution Delay (Seconds)
         * @type {number || null}
         */
        this.ProcessDelay = null;

        /**
         * Source Topic ID Region Information
         * @type {string || null}
         */
        this.SrcTopicRegion = null;

        /**
         * Syntax Rules: 0 Lucene syntax, 1 CQL syntaxNote: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.SyntaxRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.SrcTopicId = 'SrcTopicId' in params ? params.SrcTopicId : null;
        this.SrcTopicName = 'SrcTopicName' in params ? params.SrcTopicName : null;

        if (params.DstResource) {
            let obj = new ScheduledSqlResouceInfo();
            obj.deserialize(params.DstResource)
            this.DstResource = obj;
        }
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.EnableFlag = 'EnableFlag' in params ? params.EnableFlag : null;
        this.ScheduledSqlContent = 'ScheduledSqlContent' in params ? params.ScheduledSqlContent : null;
        this.ProcessStartTime = 'ProcessStartTime' in params ? params.ProcessStartTime : null;
        this.ProcessType = 'ProcessType' in params ? params.ProcessType : null;
        this.ProcessEndTime = 'ProcessEndTime' in params ? params.ProcessEndTime : null;
        this.ProcessPeriod = 'ProcessPeriod' in params ? params.ProcessPeriod : null;
        this.ProcessTimeWindow = 'ProcessTimeWindow' in params ? params.ProcessTimeWindow : null;
        this.ProcessDelay = 'ProcessDelay' in params ? params.ProcessDelay : null;
        this.SrcTopicRegion = 'SrcTopicRegion' in params ? params.SrcTopicRegion : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;

    }
}

/**
 * DescribeConfigMachineGroups request structure.
 * @class
 */
class DescribeConfigMachineGroupsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection configuration ID
         * @type {string || null}
         */
        this.ConfigId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ConfigId = 'ConfigId' in params ? params.ConfigId : null;

    }
}

/**
 * Metadata information
 * @class
 */
class MetaTagInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Metadata key
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Metadata value
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * CreateCosRecharge request structure.
 * @class
 */
class CreateCosRechargeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * ID of the log topic.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * ID of the logset.
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Shipping task name.
         * @type {string || null}
         */
        this.Name = null;

        /**
         * COS bucket, see the supported [bucket naming conventions](https://intl.cloud.tencent.com/document/product/436/13312?from_cn_redirect=1).
         * @type {string || null}
         */
        this.Bucket = null;

        /**
         * The region where the COS bucket is located, see the supported [region list](https://intl.cloud.tencent.com/document/product/436/6224?from_cn_redirect=1).
         * @type {string || null}
         */
        this.BucketRegion = null;

        /**
         * The prefix of the folder where COS files are located.
         * @type {string || null}
         */
        this.Prefix = null;

        /**
         * The type of log collected. `json_log`: JSON logs; `delimiter_log`: separator logs; `minimalist_log`: full text in a single line
Default value: `minimalist_log`
         * @type {string || null}
         */
        this.LogType = null;

        /**
         * Valid values: supported: "", "gzip", "lzop", "snappy"; Default value: "".
         * @type {string || null}
         */
        this.Compress = null;

        /**
         * Extraction rule. If `ExtractRule` is set, `LogType` must be set.
         * @type {ExtractRuleInfo || null}
         */
        this.ExtractRuleInfo = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.Bucket = 'Bucket' in params ? params.Bucket : null;
        this.BucketRegion = 'BucketRegion' in params ? params.BucketRegion : null;
        this.Prefix = 'Prefix' in params ? params.Prefix : null;
        this.LogType = 'LogType' in params ? params.LogType : null;
        this.Compress = 'Compress' in params ? params.Compress : null;

        if (params.ExtractRuleInfo) {
            let obj = new ExtractRuleInfo();
            obj.deserialize(params.ExtractRuleInfo)
            this.ExtractRuleInfo = obj;
        }

    }
}

/**
 * DescribeConfigs response structure.
 * @class
 */
class DescribeConfigsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection configuration list
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<ConfigInfo> || null}
         */
        this.Configs = null;

        /**
         * Total number of filtered items
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Configs) {
            this.Configs = new Array();
            for (let z in params.Configs) {
                let obj = new ConfigInfo();
                obj.deserialize(params.Configs[z]);
                this.Configs.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Log extraction rule
 * @class
 */
class ExtractRuleInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Key name for the time field. TikeKey and TimeFormat must appear in pairsNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TimeKey = null;

        /**
         * Time field format. For more information, please see the output parameters of the time format description of the `strftime` function in C language
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TimeFormat = null;

        /**
         * Delimiter for log type. Valid only when LogType is delimiter_logNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Delimiter = null;

        /**
         * Full log matching rule. Valid only if LogType is fullregex_logNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogRegex = null;

        /**
         * Line beginning matching rule, valid only if LogType is multiline_log or fullregex_logNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.BeginRegex = null;

        /**
         * Key name of each extracted field. An empty key indicates discarding the field. Valid only if LogType is delimiter_log. json_log logs use the key of JSON itself. Limited to 100.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.Keys = null;

        /**
         * Log filter rule list (previous version), keys to be filtered in the log and their corresponding regex.Note: For LogListener version 2.9.3 and later, it is recommended to use the AdvanceFilterRules configuration for log filtering.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<KeyRegexInfo> || null}
         */
        this.FilterKeyRegex = null;

        /**
         * Whether to upload the logs that failed to be parsed. Valid values: `true`: yes; `false`: no
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.UnMatchUpLoadSwitch = null;

        /**
         * Unmatched log key
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UnMatchLogKey = null;

        /**
         * Backtracking data volume under incremental collection pattern, default -1 indicates full collection; other non-negative numbers indicate incremental collection (collect logs backward from the latest position by ${Backtracking} bytes) with a maximum support of 1073741824 (1G).Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Backtracking = null;

        /**
         * Whether to be encoded in GBK format. Valid values: `0` (No) and `1` (Yes).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.IsGBK = null;

        /**
         * Whether to be formatted as JSON (standard). Valid values: `0` (No) and `1` (Yes).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.JsonStandard = null;

        /**
         * Syslog protocol. Valid values: `tcp`, `udp`.
This field can be used when you create or modify collection rule configurations.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Protocol = null;

        /**
         * Listening address and port specified by the syslog collection. Format: [ip]:[port]. Example: 127.0.0.1:9000.
This field can be used when you create or modify collection rule configurations.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Address = null;

        /**
         * `rfc3164`: Resolve logs by using the RFC 3164 protocol during the syslog collection.
`rfc5424`: Resolve logs by using the RFC 5424 protocol during the syslog collection.
`auto`: Automatically match either the RFC 3164 or RFC 5424 protocol.
This field can be used when you create or modify collection rule configurations.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.ParseProtocol = null;

        /**
         * Metadata type. Valid values:
0: Do not use metadata.
1: Use machine group metadata.
2: Use user-defined metadata.
3: Use the collection path to extract metadata.
         * @type {number || null}
         */
        this.MetadataType = null;

        /**
         * Regular expression of the collection configuration path, which is required when `MetadataType` is set to `3`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.PathRegex = null;

        /**
         * User-defined metadata, which is required when `MetadataType` is set to `2`.
         * @type {Array.<MetaTagInfo> || null}
         */
        this.MetaTags = null;

        /**
         * Windows event log collection
         * @type {Array.<EventLog> || null}
         */
        this.EventLogRules = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TimeKey = 'TimeKey' in params ? params.TimeKey : null;
        this.TimeFormat = 'TimeFormat' in params ? params.TimeFormat : null;
        this.Delimiter = 'Delimiter' in params ? params.Delimiter : null;
        this.LogRegex = 'LogRegex' in params ? params.LogRegex : null;
        this.BeginRegex = 'BeginRegex' in params ? params.BeginRegex : null;
        this.Keys = 'Keys' in params ? params.Keys : null;

        if (params.FilterKeyRegex) {
            this.FilterKeyRegex = new Array();
            for (let z in params.FilterKeyRegex) {
                let obj = new KeyRegexInfo();
                obj.deserialize(params.FilterKeyRegex[z]);
                this.FilterKeyRegex.push(obj);
            }
        }
        this.UnMatchUpLoadSwitch = 'UnMatchUpLoadSwitch' in params ? params.UnMatchUpLoadSwitch : null;
        this.UnMatchLogKey = 'UnMatchLogKey' in params ? params.UnMatchLogKey : null;
        this.Backtracking = 'Backtracking' in params ? params.Backtracking : null;
        this.IsGBK = 'IsGBK' in params ? params.IsGBK : null;
        this.JsonStandard = 'JsonStandard' in params ? params.JsonStandard : null;
        this.Protocol = 'Protocol' in params ? params.Protocol : null;
        this.Address = 'Address' in params ? params.Address : null;
        this.ParseProtocol = 'ParseProtocol' in params ? params.ParseProtocol : null;
        this.MetadataType = 'MetadataType' in params ? params.MetadataType : null;
        this.PathRegex = 'PathRegex' in params ? params.PathRegex : null;

        if (params.MetaTags) {
            this.MetaTags = new Array();
            for (let z in params.MetaTags) {
                let obj = new MetaTagInfo();
                obj.deserialize(params.MetaTags[z]);
                this.MetaTags.push(obj);
            }
        }

        if (params.EventLogRules) {
            this.EventLogRules = new Array();
            for (let z in params.EventLogRules) {
                let obj = new EventLog();
                obj.deserialize(params.EventLogRules[z]);
                this.EventLogRules.push(obj);
            }
        }

    }
}

/**
 * CreateAlarmShield response structure.
 * @class
 */
class CreateAlarmShieldResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Blocking Rule ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteDataTransform response structure.
 * @class
 */
class DeleteDataTransformResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Shipping task information
 * @class
 */
class ShipperTaskInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping task ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Shipping information ID
         * @type {string || null}
         */
        this.ShipperId = null;

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Start timestamp of the current batch of shipped logs in milliseconds
         * @type {number || null}
         */
        this.RangeStart = null;

        /**
         * End timestamp of the current batch of shipped logs in milliseconds
         * @type {number || null}
         */
        this.RangeEnd = null;

        /**
         * Start timestamp of the current shipping task in milliseconds
         * @type {number || null}
         */
        this.StartTime = null;

        /**
         * End timestamp of the current shipping task in milliseconds
         * @type {number || null}
         */
        this.EndTime = null;

        /**
         * Result of the current shipping task. Valid values: `success`, `running`, `failed`
         * @type {string || null}
         */
        this.Status = null;

        /**
         * Result details
         * @type {string || null}
         */
        this.Message = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.ShipperId = 'ShipperId' in params ? params.ShipperId : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.RangeStart = 'RangeStart' in params ? params.RangeStart : null;
        this.RangeEnd = 'RangeEnd' in params ? params.RangeEnd : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.Message = 'Message' in params ? params.Message : null;

    }
}

/**
 * ModifyConsumer request structure.
 * @class
 */
class ModifyConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID bound to the task
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Whether the shipping task takes effect (default: no)
         * @type {boolean || null}
         */
        this.Effective = null;

        /**
         * Whether to deliver log Metadata information; the default is true.When NeedContent is true: Content field is valid.When NeedContent is false: Content field is invalid.
         * @type {boolean || null}
         */
        this.NeedContent = null;

        /**
         * Metadata to ship if `NeedContent` is `true`
         * @type {ConsumerContent || null}
         */
        this.Content = null;

        /**
         * CKafka information
         * @type {Ckafka || null}
         */
        this.Ckafka = null;

        /**
         * Compression method during delivery. Valid values: 0, 2, and 3. [0: NONE; 2: SNAPPY; 3: LZ4]
         * @type {number || null}
         */
        this.Compression = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Effective = 'Effective' in params ? params.Effective : null;
        this.NeedContent = 'NeedContent' in params ? params.NeedContent : null;

        if (params.Content) {
            let obj = new ConsumerContent();
            obj.deserialize(params.Content)
            this.Content = obj;
        }

        if (params.Ckafka) {
            let obj = new Ckafka();
            obj.deserialize(params.Ckafka)
            this.Ckafka = obj;
        }
        this.Compression = 'Compression' in params ? params.Compression : null;

    }
}

/**
 * CreateIndex response structure.
 * @class
 */
class CreateIndexResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteConfigFromMachineGroup response structure.
 * @class
 */
class DeleteConfigFromMachineGroupResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateConsumer response structure.
 * @class
 */
class CreateConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyMachineGroup response structure.
 * @class
 */
class ModifyMachineGroupResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Information about the resource for data processing
 * @class
 */
class DataTransformResouceInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Target topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Alias
         * @type {string || null}
         */
        this.Alias = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Alias = 'Alias' in params ? params.Alias : null;

    }
}

/**
 * DeleteMachineGroup request structure.
 * @class
 */
class DeleteMachineGroupRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;

    }
}

/**
 * Full-Text index configuration
 * @class
 */
class FullTextInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Case sensitivity
         * @type {boolean || null}
         */
        this.CaseSensitive = null;

        /**
         * Separator of the full-text index. Each character represents a separator.
Only symbols, \n\t\r, and escape character \ are supported.
Note: \n\t\r can be directly enclosed in double quotes as the input parameter without escaping. When debugging with API Explorer, use the JSON parameter input method to avoid repeated escaping of \n\t\r.
         * @type {string || null}
         */
        this.Tokenizer = null;

        /**
         * Whether Chinese characters are contained
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.ContainZH = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.CaseSensitive = 'CaseSensitive' in params ? params.CaseSensitive : null;
        this.Tokenizer = 'Tokenizer' in params ? params.Tokenizer : null;
        this.ContainZH = 'ContainZH' in params ? params.ContainZH : null;

    }
}

/**
 * QueryMetric response structure.
 * @class
 */
class QueryMetricResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Metric Query Result Type
         * @type {string || null}
         */
        this.ResultType = null;

        /**
         * Metric Query Result
         * @type {string || null}
         */
        this.Result = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ResultType = 'ResultType' in params ? params.ResultType : null;
        this.Result = 'Result' in params ? params.Result : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeAlarmShields request structure.
 * @class
 */
class DescribeAlarmShieldsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Notification Channel Group ID
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

        /**
         * - taskId: Filter by [Rule ID]. Type: String. Optional: No
- status: Filter by [Rule Status]. Type: String. Supports 0: Not yet effective, 1: In Effect, 2: Expired. Optional: No
Each request can have up to 10 Filters. The upper limit of Filter.Values is 100.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100.
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * DescribePartitions response structure.
 * @class
 */
class DescribePartitionsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Partition list
         * @type {Array.<PartitionInfo> || null}
         */
        this.Partitions = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Partitions) {
            this.Partitions = new Array();
            for (let z in params.Partitions) {
                let obj = new PartitionInfo();
                obj.deserialize(params.Partitions[z]);
                this.Partitions.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeConfigMachineGroups response structure.
 * @class
 */
class DescribeConfigMachineGroupsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * List of machine groups bound to the collection rule configuration
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<MachineGroupInfo> || null}
         */
        this.MachineGroups = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.MachineGroups) {
            this.MachineGroups = new Array();
            for (let z in params.MachineGroups) {
                let obj = new MachineGroupInfo();
                obj.deserialize(params.MachineGroups[z]);
                this.MachineGroups.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyAlarm request structure.
 * @class
 */
class ModifyAlarmRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm policy ID
         * @type {string || null}
         */
        this.AlarmId = null;

        /**
         * Alarm policy name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Monitoring task running time point
         * @type {MonitorTime || null}
         */
        this.MonitorTime = null;

        /**
         * Trigger condition. Note: - Condition and AlarmLevel are one set of configurations, MultiConditions is another set of configurations. The two sets of configurations are mutually exclusive.
         * @type {string || null}
         */
        this.Condition = null;

        /**
         * Alarm level.0: Warning (Warn); 1: Reminder (Info); 2: Urgent (Critical)

Note: - Condition and AlarmLevel are one set of configurations, MultiConditions is another set of configurations. The two sets of configurations are mutually exclusive.
         * @type {number || null}
         */
        this.AlarmLevel = null;

        /**
         * Multiple trigger conditions. Note: - Condition and AlarmLevel are one set of configurations, MultiConditions is another set of configurations. The two sets of configurations are mutually exclusive.
         * @type {Array.<MultiCondition> || null}
         */
        this.MultiConditions = null;

        /**
         * Alarm persistence cycle. An alarm will be triggered only after the corresponding trigger condition is met for the number of times specified by `TriggerCount`. Value range: 1 to 10
         * @type {number || null}
         */
        this.TriggerCount = null;

        /**
         * Repeated alarm interval in minutes. Value range: 0 to 1440
         * @type {number || null}
         */
        this.AlarmPeriod = null;

        /**
         * List of associated alarm notification templates
         * @type {Array.<string> || null}
         */
        this.AlarmNoticeIds = null;

        /**
         * Monitoring object list
         * @type {Array.<AlarmTarget> || null}
         */
        this.AlarmTargets = null;

        /**
         * Whether to enable the alarm policy
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * This parameter has been deprecated. Use the Status parameter to control whether to enable the alarm policy.
         * @type {boolean || null}
         */
        this.Enable = null;

        /**
         * Custom alarm content
         * @type {string || null}
         */
        this.MessageTemplate = null;

        /**
         * Custom callback
         * @type {CallBackInfo || null}
         */
        this.CallBack = null;

        /**
         * Multi-Dimensional analysis
         * @type {Array.<AnalysisDimensional> || null}
         */
        this.Analysis = null;

        /**
         * Group trigger status. true: enabled; false: disabled (default)
         * @type {boolean || null}
         */
        this.GroupTriggerStatus = null;

        /**
         * Grouping trigger conditions.
         * @type {Array.<string> || null}
         */
        this.GroupTriggerCondition = null;

        /**
         * Tag description list, by specifying this parameter, you can simultaneously bind a Tag to the corresponding alarm policy. Up to 10 Tag key-value pairs are supported, and they must be unique.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Monitored Object Type. 0: common monitoring objects for execution statements; 1: separately selected monitoring objects for each execution statement.When the value is 1, the number of AlarmTargets Elements (XML) cannot exceed 10, and the Numbers in AlarmTargets must be continuous positive integers starting from 1, without duplication.

         * @type {number || null}
         */
        this.MonitorObjectType = null;

        /**
         * Alarm additional classification information list.
The number of Classifications elements cannot exceed 20.The Key of Classifications element must not be empty and duplicated, and its length cannot exceed 50 characters, complying with the regular expression ^[a-z]([a-z0-9_]{0,49})$.The Value length of Classifications element cannot exceed 200 characters.
         * @type {Array.<AlarmClassification> || null}
         */
        this.Classifications = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmId = 'AlarmId' in params ? params.AlarmId : null;
        this.Name = 'Name' in params ? params.Name : null;

        if (params.MonitorTime) {
            let obj = new MonitorTime();
            obj.deserialize(params.MonitorTime)
            this.MonitorTime = obj;
        }
        this.Condition = 'Condition' in params ? params.Condition : null;
        this.AlarmLevel = 'AlarmLevel' in params ? params.AlarmLevel : null;

        if (params.MultiConditions) {
            this.MultiConditions = new Array();
            for (let z in params.MultiConditions) {
                let obj = new MultiCondition();
                obj.deserialize(params.MultiConditions[z]);
                this.MultiConditions.push(obj);
            }
        }
        this.TriggerCount = 'TriggerCount' in params ? params.TriggerCount : null;
        this.AlarmPeriod = 'AlarmPeriod' in params ? params.AlarmPeriod : null;
        this.AlarmNoticeIds = 'AlarmNoticeIds' in params ? params.AlarmNoticeIds : null;

        if (params.AlarmTargets) {
            this.AlarmTargets = new Array();
            for (let z in params.AlarmTargets) {
                let obj = new AlarmTarget();
                obj.deserialize(params.AlarmTargets[z]);
                this.AlarmTargets.push(obj);
            }
        }
        this.Status = 'Status' in params ? params.Status : null;
        this.Enable = 'Enable' in params ? params.Enable : null;
        this.MessageTemplate = 'MessageTemplate' in params ? params.MessageTemplate : null;

        if (params.CallBack) {
            let obj = new CallBackInfo();
            obj.deserialize(params.CallBack)
            this.CallBack = obj;
        }

        if (params.Analysis) {
            this.Analysis = new Array();
            for (let z in params.Analysis) {
                let obj = new AnalysisDimensional();
                obj.deserialize(params.Analysis[z]);
                this.Analysis.push(obj);
            }
        }
        this.GroupTriggerStatus = 'GroupTriggerStatus' in params ? params.GroupTriggerStatus : null;
        this.GroupTriggerCondition = 'GroupTriggerCondition' in params ? params.GroupTriggerCondition : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.MonitorObjectType = 'MonitorObjectType' in params ? params.MonitorObjectType : null;

        if (params.Classifications) {
            this.Classifications = new Array();
            for (let z in params.Classifications) {
                let obj = new AlarmClassification();
                obj.deserialize(params.Classifications[z]);
                this.Classifications.push(obj);
            }
        }

    }
}

/**
 * DescribeTopics response structure.
 * @class
 */
class DescribeTopicsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic list
         * @type {Array.<TopicInfo> || null}
         */
        this.Topics = null;

        /**
         * Total number
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Topics) {
            this.Topics = new Array();
            for (let z in params.Topics) {
                let obj = new TopicInfo();
                obj.deserialize(params.Topics[z]);
                this.Topics.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * `LogItem` array
 * @class
 */
class LogItems extends  AbstractModel {
    constructor(){
        super();

        /**
         * Key-Value pair returned in analysis result
         * @type {Array.<LogItem> || null}
         */
        this.Data = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Data) {
            this.Data = new Array();
            for (let z in params.Data) {
                let obj = new LogItem();
                obj.deserialize(params.Data[z]);
                this.Data.push(obj);
            }
        }

    }
}

/**
 * ModifyAlarmNotice request structure.
 * @class
 */
class ModifyAlarmNoticeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Notification group ID
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

        /**
         * Notification group name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Notification type. Optional Values:
<li> Trigger - Alarm trigger</li>
<li> Recovery - Alarm recovery</li>
<li> All - Alarm triggered and alarm recovery</li>
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Notification recipient
         * @type {Array.<NoticeReceiver> || null}
         */
        this.NoticeReceivers = null;

        /**
         * API callback information (including WeCom)
         * @type {Array.<WebCallback> || null}
         */
        this.WebCallbacks = null;

        /**
         * Notification rulesNote: - Type, NoticeReceivers, and WebCallbacks are one set of configurations, while NoticeRules is another set of configurations. The two sets are mutually exclusive.- Submitting one set of data will nullify the other set.
         * @type {Array.<NoticeRule> || null}
         */
        this.NoticeRules = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.Type = 'Type' in params ? params.Type : null;

        if (params.NoticeReceivers) {
            this.NoticeReceivers = new Array();
            for (let z in params.NoticeReceivers) {
                let obj = new NoticeReceiver();
                obj.deserialize(params.NoticeReceivers[z]);
                this.NoticeReceivers.push(obj);
            }
        }

        if (params.WebCallbacks) {
            this.WebCallbacks = new Array();
            for (let z in params.WebCallbacks) {
                let obj = new WebCallback();
                obj.deserialize(params.WebCallbacks[z]);
                this.WebCallbacks.push(obj);
            }
        }

        if (params.NoticeRules) {
            this.NoticeRules = new Array();
            for (let z in params.NoticeRules) {
                let obj = new NoticeRule();
                obj.deserialize(params.NoticeRules[z]);
                this.NoticeRules.push(obj);
            }
        }

    }
}

/**
 * 
 * @class
 */
class TopicExtendInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * 
         * @type {AnonymousInfo || null}
         */
        this.AnonymousAccess = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.AnonymousAccess) {
            let obj = new AnonymousInfo();
            obj.deserialize(params.AnonymousAccess)
            this.AnonymousAccess = obj;
        }

    }
}

/**
 * Windows event log collection configuration
 * @class
 */
class EventLog extends  AbstractModel {
    constructor(){
        super();

        /**
         * Event channel, supports Application, Security, Setup, System, ALL

         * @type {string || null}
         */
        this.EventChannel = null;

        /**
         * Time type, 1: User-defined, 2: Current time
         * @type {number || null}
         */
        this.TimeType = null;

        /**
         * Time, when choosing custom time type, a specific time is required
         * @type {number || null}
         */
        this.Timestamp = null;

        /**
         * Event ID filter list
         * @type {Array.<string> || null}
         */
        this.EventIDs = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.EventChannel = 'EventChannel' in params ? params.EventChannel : null;
        this.TimeType = 'TimeType' in params ? params.TimeType : null;
        this.Timestamp = 'Timestamp' in params ? params.Timestamp : null;
        this.EventIDs = 'EventIDs' in params ? params.EventIDs : null;

    }
}

/**
 * CreateAlarm request structure.
 * @class
 */
class CreateAlarmRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm policy name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Monitoring object list
         * @type {Array.<AlarmTarget> || null}
         */
        this.AlarmTargets = null;

        /**
         * Monitoring task running time point
         * @type {MonitorTime || null}
         */
        this.MonitorTime = null;

        /**
         * Alarm persistence cycle. An alarm will be triggered only after the corresponding trigger condition is met for the number of times specified by `TriggerCount`. Value range: 1–10.
         * @type {number || null}
         */
        this.TriggerCount = null;

        /**
         * Alarm repeat interval in minutes. The value range is 0~1440.
         * @type {number || null}
         */
        this.AlarmPeriod = null;

        /**
         * List of associated alarm notification templates
         * @type {Array.<string> || null}
         */
        this.AlarmNoticeIds = null;

        /**
         * Trigger ConditionNote:- Condition and AlarmLevel are one set of configurations, MultiConditions is another set of configurations. The two sets of configurations are mutually exclusive.
         * @type {string || null}
         */
        this.Condition = null;

        /**
         * Alarm Level0: Warning (Warn); 1: Reminder (Info); 2: Urgent (Critical).
Note:- If not specified, the default is 0.
- Condition and AlarmLevel are one set of configurations, MultiConditions is another set of configurations. The two sets of configurations are mutually exclusive.
         * @type {number || null}
         */
        this.AlarmLevel = null;

        /**
         * Multiple trigger conditions
Note:- Condition and AlarmLevel form one set of configurations, while MultiConditions form another set of configurations, and the two sets are mutually exclusive.



         * @type {Array.<MultiCondition> || null}
         */
        this.MultiConditions = null;

        /**
         * Whether to enable the alarm policyThe default value is true
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * This parameter has been deprecated, please use the Status parameter to control whether to enable the alarm policy.
         * @type {boolean || null}
         */
        this.Enable = null;

        /**
         * Custom alarm content
         * @type {string || null}
         */
        this.MessageTemplate = null;

        /**
         * Custom callback
         * @type {CallBackInfo || null}
         */
        this.CallBack = null;

        /**
         * Multi-Dimensional analysis
         * @type {Array.<AnalysisDimensional> || null}
         */
        this.Analysis = null;

        /**
         * Group trigger status.
Default value is false
         * @type {boolean || null}
         */
        this.GroupTriggerStatus = null;

        /**
         * Grouping Trigger Conditions.
         * @type {Array.<string> || null}
         */
        this.GroupTriggerCondition = null;

        /**
         * Tag description list, by specifying this parameter, you can simultaneously bind Tag to the corresponding alarm policy.Supports up to 10 Tag key-value pairs, and the pairs must be unique.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Monitored Object Type. 0: common monitoring objects for execution statements; 1: separately selected monitoring objects for each execution statement.If not specified, the default value is 0.When the value is 1, the number of AlarmTargets Elements (XML) cannot exceed 10, and the Numbers in AlarmTargets must be continuous positive integers starting from 1, without duplication.

         * @type {number || null}
         */
        this.MonitorObjectType = null;

        /**
         * Alarms additional classification information listThe number of Classifications elements cannot exceed 20.The Key of Classifications element must not be empty and duplicated, and its length cannot exceed 50 characters, complying with the regular expression ^[a-z]([a-z0-9_]{0,49})$.The Value length of Classifications element cannot exceed 200 characters.
         * @type {Array.<AlarmClassification> || null}
         */
        this.Classifications = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;

        if (params.AlarmTargets) {
            this.AlarmTargets = new Array();
            for (let z in params.AlarmTargets) {
                let obj = new AlarmTarget();
                obj.deserialize(params.AlarmTargets[z]);
                this.AlarmTargets.push(obj);
            }
        }

        if (params.MonitorTime) {
            let obj = new MonitorTime();
            obj.deserialize(params.MonitorTime)
            this.MonitorTime = obj;
        }
        this.TriggerCount = 'TriggerCount' in params ? params.TriggerCount : null;
        this.AlarmPeriod = 'AlarmPeriod' in params ? params.AlarmPeriod : null;
        this.AlarmNoticeIds = 'AlarmNoticeIds' in params ? params.AlarmNoticeIds : null;
        this.Condition = 'Condition' in params ? params.Condition : null;
        this.AlarmLevel = 'AlarmLevel' in params ? params.AlarmLevel : null;

        if (params.MultiConditions) {
            this.MultiConditions = new Array();
            for (let z in params.MultiConditions) {
                let obj = new MultiCondition();
                obj.deserialize(params.MultiConditions[z]);
                this.MultiConditions.push(obj);
            }
        }
        this.Status = 'Status' in params ? params.Status : null;
        this.Enable = 'Enable' in params ? params.Enable : null;
        this.MessageTemplate = 'MessageTemplate' in params ? params.MessageTemplate : null;

        if (params.CallBack) {
            let obj = new CallBackInfo();
            obj.deserialize(params.CallBack)
            this.CallBack = obj;
        }

        if (params.Analysis) {
            this.Analysis = new Array();
            for (let z in params.Analysis) {
                let obj = new AnalysisDimensional();
                obj.deserialize(params.Analysis[z]);
                this.Analysis.push(obj);
            }
        }
        this.GroupTriggerStatus = 'GroupTriggerStatus' in params ? params.GroupTriggerStatus : null;
        this.GroupTriggerCondition = 'GroupTriggerCondition' in params ? params.GroupTriggerCondition : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.MonitorObjectType = 'MonitorObjectType' in params ? params.MonitorObjectType : null;

        if (params.Classifications) {
            this.Classifications = new Array();
            for (let z in params.Classifications) {
                let obj = new AlarmClassification();
                obj.deserialize(params.Classifications[z]);
                this.Classifications.push(obj);
            }
        }

    }
}

/**
 * DeleteExport response structure.
 * @class
 */
class DeleteExportResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Multiple log topic search for topic information
 * @class
 */
class SearchLogInfos extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log Topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Log storage lifetime
         * @type {number || null}
         */
        this.Period = null;

        /**
         * You can pass through the Context value returned by this API to continue to get more logs. Expire time: 1 hour.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Context = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Period = 'Period' in params ? params.Period : null;
        this.Context = 'Context' in params ? params.Context : null;

    }
}

/**
 * Log topic partition information
 * @class
 */
class PartitionInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Partition ID
         * @type {number || null}
         */
        this.PartitionId = null;

        /**
         * Partition status. Valid values: `readwrite`, `readonly`
         * @type {string || null}
         */
        this.Status = null;

        /**
         * Partition hash start key
         * @type {string || null}
         */
        this.InclusiveBeginKey = null;

        /**
         * Partition hash end key
         * @type {string || null}
         */
        this.ExclusiveEndKey = null;

        /**
         * Partition creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Last modified of read-only partition
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LastWriteTime = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.PartitionId = 'PartitionId' in params ? params.PartitionId : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.InclusiveBeginKey = 'InclusiveBeginKey' in params ? params.InclusiveBeginKey : null;
        this.ExclusiveEndKey = 'ExclusiveEndKey' in params ? params.ExclusiveEndKey : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.LastWriteTime = 'LastWriteTime' in params ? params.LastWriteTime : null;

    }
}

/**
 * DeleteScheduledSql response structure.
 * @class
 */
class DeleteScheduledSqlResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Alarm record details
 * @class
 */
class AlertHistoryRecord extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm record ID
         * @type {string || null}
         */
        this.RecordId = null;

        /**
         * Alarm policy ID
         * @type {string || null}
         */
        this.AlarmId = null;

        /**
         * Alarm policy name
         * @type {string || null}
         */
        this.AlarmName = null;

        /**
         * ID of the monitored object
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Name of the monitored object
         * @type {string || null}
         */
        this.TopicName = null;

        /**
         * Region of the monitored object
         * @type {string || null}
         */
        this.Region = null;

        /**
         * Trigger condition
         * @type {string || null}
         */
        this.Trigger = null;

        /**
         * Number of cycles for which the alarm lasts. An alarm will be triggered only after the trigger condition is met for the number of cycles specified by `TriggerCount`.
         * @type {number || null}
         */
        this.TriggerCount = null;

        /**
         * Alarm notification frequency (minutes)
         * @type {number || null}
         */
        this.AlarmPeriod = null;

        /**
         * Notification group
         * @type {Array.<AlertHistoryNotice> || null}
         */
        this.Notices = null;

        /**
         * Alarm duration (minutes)
         * @type {number || null}
         */
        this.Duration = null;

        /**
         * Alarm status. Valid values: `0` (uncleared), `1` (cleared), `2` (expired)
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Alarm generation time, which is a Unix timestamp in ms
         * @type {number || null}
         */
        this.CreateTime = null;

        /**
         * Group information corresponding to triggering by group
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<GroupTriggerConditionInfo> || null}
         */
        this.GroupTriggerCondition = null;

        /**
         * Alarm severity. Valid values: `0` (Warn), `1` (Info), `2` (Critical)
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.AlarmLevel = null;

        /**
         * Type of the monitored object
`0`: The same object is specified for all statements. `1`: An object is separately specified for each statement. 
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.MonitorObjectType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RecordId = 'RecordId' in params ? params.RecordId : null;
        this.AlarmId = 'AlarmId' in params ? params.AlarmId : null;
        this.AlarmName = 'AlarmName' in params ? params.AlarmName : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.TopicName = 'TopicName' in params ? params.TopicName : null;
        this.Region = 'Region' in params ? params.Region : null;
        this.Trigger = 'Trigger' in params ? params.Trigger : null;
        this.TriggerCount = 'TriggerCount' in params ? params.TriggerCount : null;
        this.AlarmPeriod = 'AlarmPeriod' in params ? params.AlarmPeriod : null;

        if (params.Notices) {
            this.Notices = new Array();
            for (let z in params.Notices) {
                let obj = new AlertHistoryNotice();
                obj.deserialize(params.Notices[z]);
                this.Notices.push(obj);
            }
        }
        this.Duration = 'Duration' in params ? params.Duration : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;

        if (params.GroupTriggerCondition) {
            this.GroupTriggerCondition = new Array();
            for (let z in params.GroupTriggerCondition) {
                let obj = new GroupTriggerConditionInfo();
                obj.deserialize(params.GroupTriggerCondition[z]);
                this.GroupTriggerCondition.push(obj);
            }
        }
        this.AlarmLevel = 'AlarmLevel' in params ? params.AlarmLevel : null;
        this.MonitorObjectType = 'MonitorObjectType' in params ? params.MonitorObjectType : null;

    }
}

/**
 * Blocklist path information
 * @class
 */
class ExcludePathInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Type. Valid values: `File`, `Path`
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Specific content corresponding to `Type`
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Type = 'Type' in params ? params.Type : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * Filter rule for shipped log
 * @class
 */
class FilterRuleInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Filter rule key
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Filter rule
         * @type {string || null}
         */
        this.Regex = null;

        /**
         * Filter rule value
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Regex = 'Regex' in params ? params.Regex : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * ModifyKafkaConsumer request structure.
 * @class
 */
class ModifyKafkaConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log Topic ID
         * @type {string || null}
         */
        this.FromTopicId = null;

        /**
         * Compression mode [0: NONE; 2: SNAPPY; 3: LZ4]
         * @type {number || null}
         */
        this.Compression = null;

        /**
         * Kafka protocol consumer data format
         * @type {KafkaConsumerContent || null}
         */
        this.ConsumerContent = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.FromTopicId = 'FromTopicId' in params ? params.FromTopicId : null;
        this.Compression = 'Compression' in params ? params.Compression : null;

        if (params.ConsumerContent) {
            let obj = new KafkaConsumerContent();
            obj.deserialize(params.ConsumerContent)
            this.ConsumerContent = obj;
        }

    }
}

/**
 * CreateMachineGroup response structure.
 * @class
 */
class CreateMachineGroupResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * SplitPartition request structure.
 * @class
 */
class SplitPartitionRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * ID of the partition to be split
         * @type {number || null}
         */
        this.PartitionId = null;

        /**
         * Partition split hash key position, which is meaningful only if `Number=2` is set
         * @type {string || null}
         */
        this.SplitKey = null;

        /**
         * Number of partitions to split into, which is optional. Default value: 2
         * @type {number || null}
         */
        this.Number = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.PartitionId = 'PartitionId' in params ? params.PartitionId : null;
        this.SplitKey = 'SplitKey' in params ? params.SplitKey : null;
        this.Number = 'Number' in params ? params.Number : null;

    }
}

/**
 * CheckRechargeKafkaServer request structure.
 * @class
 */
class CheckRechargeKafkaServerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Kafka type. Valid values: 0 (Tencent Cloud CKafka) and 1 (customer's Kafka).
         * @type {number || null}
         */
        this.KafkaType = null;

        /**
         * Tencent Cloud CKafka Instance IDWhen KafkaType is 0, KafkaInstance is required
         * @type {string || null}
         */
        this.KafkaInstance = null;

        /**
         * Service AddressWhen KafkaType is 1, ServerAddr is required
         * @type {string || null}
         */
        this.ServerAddr = null;

        /**
         * Whether the service address uses an encrypted connection
         * @type {boolean || null}
         */
        this.IsEncryptionAddr = null;

        /**
         * Encryption access protocol. Required when IsEncryptionAddr parameter is set to true
         * @type {KafkaProtocolInfo || null}
         */
        this.Protocol = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.KafkaType = 'KafkaType' in params ? params.KafkaType : null;
        this.KafkaInstance = 'KafkaInstance' in params ? params.KafkaInstance : null;
        this.ServerAddr = 'ServerAddr' in params ? params.ServerAddr : null;
        this.IsEncryptionAddr = 'IsEncryptionAddr' in params ? params.IsEncryptionAddr : null;

        if (params.Protocol) {
            let obj = new KafkaProtocolInfo();
            obj.deserialize(params.Protocol)
            this.Protocol = obj;
        }

    }
}

/**
 * CreateAlarmShield request structure.
 * @class
 */
class CreateAlarmShieldRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Notification Channel Group ID
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

        /**
         * Block start time (second-level timestamp).
         * @type {number || null}
         */
        this.StartTime = null;

        /**
         * Block end time (second-level timestamp).
         * @type {number || null}
         */
        this.EndTime = null;

        /**
         * Block type. 1: Block all notifications, 2: Block matching rules notifications according to the Rule parameter.
         * @type {number || null}
         */
        this.Type = null;

        /**
         * Blocking reason.
         * @type {string || null}
         */
        this.Reason = null;

        /**
         * Blocking rules, required when Type is 2. For detailed information on filling in rules, see [Product Documentation](https://intl.cloud.tencent.com/document/product/614/103178?from_cn_redirect=1#rule).
         * @type {string || null}
         */
        this.Rule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;
        this.Type = 'Type' in params ? params.Type : null;
        this.Reason = 'Reason' in params ? params.Reason : null;
        this.Rule = 'Rule' in params ? params.Rule : null;

    }
}

/**
 * Machine group information
 * @class
 */
class MachineGroupInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

        /**
         * Machine group name
         * @type {string || null}
         */
        this.GroupName = null;

        /**
         * Machine group type
         * @type {MachineGroupTypeInfo || null}
         */
        this.MachineGroupType = null;

        /**
         * Creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * List of tags bound to machine group
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Whether to enable automatic update for the machine group
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.AutoUpdate = null;

        /**
         * Update start time. We recommend you update LogListener during off-peak hours.
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UpdateStartTime = null;

        /**
         * Update end time. We recommend you update LogListener during off-peak hours.
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UpdateEndTime = null;

        /**
         * Whether to enable the service log to record the logs generated by the LogListener service itself. After it is enabled, the internal logset `cls_service_logging` and the `loglistener_status`, `loglistener_alarm`, and `loglistener_business` log topics will be created, which will not incur fees.
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.ServiceLogging = null;

        /**
         * Regular cleanup time for offline machines in the machine group
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.DelayCleanupTime = null;

        /**
         * Metadata information list of a machine group
         * @type {Array.<MetaTagInfo> || null}
         */
        this.MetaTags = null;

        /**
         * Operating system type, 0: Linux, 1: Windows
         * @type {number || null}
         */
        this.OSType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;
        this.GroupName = 'GroupName' in params ? params.GroupName : null;

        if (params.MachineGroupType) {
            let obj = new MachineGroupTypeInfo();
            obj.deserialize(params.MachineGroupType)
            this.MachineGroupType = obj;
        }
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.AutoUpdate = 'AutoUpdate' in params ? params.AutoUpdate : null;
        this.UpdateStartTime = 'UpdateStartTime' in params ? params.UpdateStartTime : null;
        this.UpdateEndTime = 'UpdateEndTime' in params ? params.UpdateEndTime : null;
        this.ServiceLogging = 'ServiceLogging' in params ? params.ServiceLogging : null;
        this.DelayCleanupTime = 'DelayCleanupTime' in params ? params.DelayCleanupTime : null;

        if (params.MetaTags) {
            this.MetaTags = new Array();
            for (let z in params.MetaTags) {
                let obj = new MetaTagInfo();
                obj.deserialize(params.MetaTags[z]);
                this.MetaTags.push(obj);
            }
        }
        this.OSType = 'OSType' in params ? params.OSType : null;

    }
}

/**
 * DescribeLogHistogram response structure.
 * @class
 */
class DescribeLogHistogramResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Statistical period in milliseconds
         * @type {number || null}
         */
        this.Interval = null;

        /**
         * The number of logs that hit the keywords
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * Statistical result details within the period
         * @type {Array.<HistogramInfo> || null}
         */
        this.HistogramInfos = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Interval = 'Interval' in params ? params.Interval : null;
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;

        if (params.HistogramInfos) {
            this.HistogramInfos = new Array();
            for (let z in params.HistogramInfos) {
                let obj = new HistogramInfo();
                obj.deserialize(params.HistogramInfos[z]);
                this.HistogramInfos.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CloseKafkaConsumer response structure.
 * @class
 */
class CloseKafkaConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteAlarmShield response structure.
 * @class
 */
class DeleteAlarmShieldResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateIndex request structure.
 * @class
 */
class CreateIndexRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Index rule
         * @type {RuleInfo || null}
         */
        this.Rule = null;

        /**
         * Whether to take effect. Default value: true
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Whether full-text indexing includes internal fields (`__FILENAME__`, `__HOSTNAME__`, and `__SOURCE__`). Default value: `false`. Recommended value: `true`.
* `false`: Full-text indexing does not include internal fields.
* `true`: Full-text indexing includes internal fields.
         * @type {boolean || null}
         */
        this.IncludeInternalFields = null;

        /**
         * Whether full-text indexing includes metadata fields (which are prefixed with `__TAG__`). Default value: `0`. Recommended value: `1`.
* `0`: Full-text indexing includes only the metadata fields with key-value indexing enabled.
* `1`: Full-text indexing includes all metadata fields.
* `2`: Full-text indexing does not include metadata fields.
         * @type {number || null}
         */
        this.MetadataFlag = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

        if (params.Rule) {
            let obj = new RuleInfo();
            obj.deserialize(params.Rule)
            this.Rule = obj;
        }
        this.Status = 'Status' in params ? params.Status : null;
        this.IncludeInternalFields = 'IncludeInternalFields' in params ? params.IncludeInternalFields : null;
        this.MetadataFlag = 'MetadataFlag' in params ? params.MetadataFlag : null;

    }
}

/**
 * DescribeLogsets response structure.
 * @class
 */
class DescribeLogsetsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Total number of pages
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * Logset list
         * @type {Array.<LogsetInfo> || null}
         */
        this.Logsets = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;

        if (params.Logsets) {
            this.Logsets = new Array();
            for (let z in params.Logsets) {
                let obj = new LogsetInfo();
                obj.deserialize(params.Logsets[z]);
                this.Logsets.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteConsumer response structure.
 * @class
 */
class DeleteConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeTopics request structure.
 * @class
 */
class DescribeTopicsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * <li>topicName: Filter by **log topic name**. Fuzzy match is implemented by default. You can use the `PreciseSearch` parameter to set exact match. Type: String. Required. No. <br><li>logsetName: Filter by **logset name**. Fuzzy match is implemented by default. You can use the `PreciseSearch` parameter to set exact match. Type: String. Required: No. <br><li>topicId: Filter by **log topic ID**. Type: String. Required: No. <br><li>logsetId: Filter by **logset ID**. You can call `DescribeLogsets` to query the list of created logsets or log in to the console to view them. You can also call `CreateLogset` to create a logset. Type: String. Required: No. <br><li>tagKey: Filter by **tag key**. Type: String. Required: No. <br><li>tag:tagKey: Filter by **tag key-value pair**. The `tagKey` should be replaced with a specified tag key, such as `tag:exampleKey`. Type: String. Required: No. <br><li>storageType: Filter by **log topic storage type**. Valid values: `hot` (standard storage) and `cold` (IA storage). Type: String. Required: No. Each request can have up to 10 `Filters` and 100 `Filter.Values`.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0.
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100.
         * @type {number || null}
         */
        this.Limit = null;

        /**
         * Match mode for `Filters` fields.
- 0: Fuzzy match for `topicName` and `logsetName`. This is the default value.
- 1: Exact match for `topicName`.
- 2: Exact match for `logsetName`.
- 3: Exact match for `topicName` and `logsetName`.
         * @type {number || null}
         */
        this.PreciseSearch = null;

        /**
         * Topic type
- 0 (default): Log topic.
- 1: Metric topic.

         * @type {number || null}
         */
        this.BizType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;
        this.PreciseSearch = 'PreciseSearch' in params ? params.PreciseSearch : null;
        this.BizType = 'BizType' in params ? params.BizType : null;

    }
}

/**
 * GetAlarmLog response structure.
 * @class
 */
class GetAlarmLogResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Context for loading subsequent details
         * @type {string || null}
         */
        this.Context = null;

        /**
         * Whether alarm execution details within a specified time range are fully returned
         * @type {boolean || null}
         */
        this.ListOver = null;

        /**
         * Whether return value is SQL analysis result or not
         * @type {boolean || null}
         */
        this.Analysis = null;

        /**
         * Column names of analysis results. If the Query statement contains an SQL query, then column names of the queried fields will be returned;Otherwise, it will be empty.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.ColNames = null;

        /**
         * Execution details query results.
When there is no SQL statement in the Query field, it returns query results.
When there is an SQL statement in the Query field, it may return null.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<LogInfo> || null}
         */
        this.Results = null;

        /**
         * Execution details statistical analysis results. When there is an SQL statement in the Query field, it returns SQL statistical results; otherwise, it may return null.

Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<LogItems> || null}
         */
        this.AnalysisResults = null;

        /**
         * Execution details statistical analysis results; only valid if UseNewAnalysis is true.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.AnalysisRecords = null;

        /**
         * Column names of analysis results, valid only if UseNewAnalysis is trueNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<Column> || null}
         */
        this.Columns = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Context = 'Context' in params ? params.Context : null;
        this.ListOver = 'ListOver' in params ? params.ListOver : null;
        this.Analysis = 'Analysis' in params ? params.Analysis : null;
        this.ColNames = 'ColNames' in params ? params.ColNames : null;

        if (params.Results) {
            this.Results = new Array();
            for (let z in params.Results) {
                let obj = new LogInfo();
                obj.deserialize(params.Results[z]);
                this.Results.push(obj);
            }
        }

        if (params.AnalysisResults) {
            this.AnalysisResults = new Array();
            for (let z in params.AnalysisResults) {
                let obj = new LogItems();
                obj.deserialize(params.AnalysisResults[z]);
                this.AnalysisResults.push(obj);
            }
        }
        this.AnalysisRecords = 'AnalysisRecords' in params ? params.AnalysisRecords : null;

        if (params.Columns) {
            this.Columns = new Array();
            for (let z in params.Columns) {
                let obj = new Column();
                obj.deserialize(params.Columns[z]);
                this.Columns.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateTopic request structure.
 * @class
 */
class CreateTopicRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Log topic name
         * @type {string || null}
         */
        this.TopicName = null;

        /**
         * Number of log topic partitions. Default value: 1. Maximum value: 10
         * @type {number || null}
         */
        this.PartitionCount = null;

        /**
         * Tag description list. This parameter is used to bind a tag to a log topic. Up to 10 tag key-value pairs are supported, and a resource can be bound to only one tag key.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Whether to enable automatic split. Default value: true
         * @type {boolean || null}
         */
        this.AutoSplit = null;

        /**
         * Maximum number of partitions to split into for this topic if automatic split is enabled. Default value: 50
         * @type {number || null}
         */
        this.MaxSplitPartitions = null;

        /**
         * Log topic storage type. Valid values: `hot` (STANDARD storage); `cold` (IA storage). Default value: `hot`.
         * @type {string || null}
         */
        this.StorageType = null;

        /**
         * lifetime. Unit: days. Standard storage value range: 1 to 3600. Infrequent storage value range: 7 to 3600 days. A value of 3640 indicates permanent retention.If this value is not input, it defaults to the Period value of the log set corresponding to the accessed log topic (defaults to 30 days in case of access failure).
         * @type {number || null}
         */
        this.Period = null;

        /**
         * Log topic description
         * @type {string || null}
         */
        this.Describes = null;

        /**
         * 0: Disable log settlement.Non-zero: The number of Standard Storage days after enabling log settlement. HotPeriod needs to be greater than or equal to 7, and less than Period.Effective only when StorageType is hot.
         * @type {number || null}
         */
        this.HotPeriod = null;

        /**
         * Authentication switch. false: off; true: on. Default is false.Once enabled, it will support specified operations for anonymous access to this log topic. For details, please see [log Topic](https://intl.cloud.tencent.com/document/product/614/41035?from_cn_redirect=1).
         * @type {boolean || null}
         */
        this.IsWebTracking = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.TopicName = 'TopicName' in params ? params.TopicName : null;
        this.PartitionCount = 'PartitionCount' in params ? params.PartitionCount : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.AutoSplit = 'AutoSplit' in params ? params.AutoSplit : null;
        this.MaxSplitPartitions = 'MaxSplitPartitions' in params ? params.MaxSplitPartitions : null;
        this.StorageType = 'StorageType' in params ? params.StorageType : null;
        this.Period = 'Period' in params ? params.Period : null;
        this.Describes = 'Describes' in params ? params.Describes : null;
        this.HotPeriod = 'HotPeriod' in params ? params.HotPeriod : null;
        this.IsWebTracking = 'IsWebTracking' in params ? params.IsWebTracking : null;

    }
}

/**
 * DescribeExports request structure.
 * @class
 */
class DescribeExportsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * DescribeMachineGroups request structure.
 * @class
 */
class DescribeMachineGroupsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * machineGroupName
- Filter by [Machine Group Name].
- Type: String
- Required: No

machineGroupId
- Filter by [Machine group ID].
- Type: String
- Required: No

osType
- Filter by [Operating System Type].
- Type: Int
- Required: No

tagKey
- Filter by [Tag key].
- Type: String
- Required: No

tag:tagKey
- Filter by [Tag key-value pair]. Replace tagKey with the specific Tag key.- Type: String
- Required: No

The maximum number of Filters per request is 10, and the maximum for Filter.Values is 5.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * DescribeCosRecharges request structure.
 * @class
 */
class DescribeCosRechargesRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * ID of the log topic.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Status. `0`: Created, `1`: Running, `2`: Stopped, `3`: Completed, `4`: Run failed
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Whether the configuration is enabled. `0`: Not enabled, `1`: Enabled
         * @type {number || null}
         */
        this.Enable = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.Enable = 'Enable' in params ? params.Enable : null;

    }
}

/**
 * Monitoring object
 * @class
 */
class AlarmTarget extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic IDNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Query statementNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Query = null;

        /**
         * Serial number of alarm object, which is incremental from 1.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Number = null;

        /**
         * Offset of the query start time from the alarm execution time in minutes. The value cannot be positive. Maximum value: 0. Minimum value: -1440.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.StartTimeOffset = null;

        /**
         * Offset of the query end time from the alarm execution time in minutes. The value cannot be positive and must be greater than StartTimeOffset. Maximum value: 0. Minimum value: -1440.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.EndTimeOffset = null;

        /**
         * Logset IDNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Search syntax rules; default value: 0.0: Lucene syntax; 1: CQL syntax.For detailed instructions, see <a href="https://intl.cloud.tencent.com/document/product/614/47044?from_cn_redirect=1#RetrievesConditionalRules" target="_blank">Search Condition Syntax Rules</a>
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.SyntaxRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.Number = 'Number' in params ? params.Number : null;
        this.StartTimeOffset = 'StartTimeOffset' in params ? params.StartTimeOffset : null;
        this.EndTimeOffset = 'EndTimeOffset' in params ? params.EndTimeOffset : null;
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;

    }
}

/**
 * CreateKafkaRecharge response structure.
 * @class
 */
class CreateKafkaRechargeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Kafka data import configuration ID
         * @type {string || null}
         */
        this.Id = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Id = 'Id' in params ? params.Id : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyScheduledSql request structure.
 * @class
 */
class ModifyScheduledSqlRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Task ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Source log topic
         * @type {string || null}
         */
        this.SrcTopicId = null;

        /**
         * Task start status. 1: Enabled, 2: Disabled
         * @type {number || null}
         */
        this.EnableFlag = null;

        /**
         * Target log topic for scheduled SQL analysis
         * @type {ScheduledSqlResouceInfo || null}
         */
        this.DstResource = null;

        /**
         * Queries statements
         * @type {string || null}
         */
        this.ScheduledSqlContent = null;

        /**
         * Scheduling interval (minutes)
         * @type {number || null}
         */
        this.ProcessPeriod = null;

        /**
         * Time window for a single query. Example: last 15 minutes
         * @type {string || null}
         */
        this.ProcessTimeWindow = null;

        /**
         * Execution delay (seconds)
         * @type {number || null}
         */
        this.ProcessDelay = null;

        /**
         * Region information of source topic ID 
         * @type {string || null}
         */
        this.SrcTopicRegion = null;

        /**
         * Task Name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Syntax rules. Default value: 0. 0: Lucene syntax, 1: CQL syntax
         * @type {number || null}
         */
        this.SyntaxRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.SrcTopicId = 'SrcTopicId' in params ? params.SrcTopicId : null;
        this.EnableFlag = 'EnableFlag' in params ? params.EnableFlag : null;

        if (params.DstResource) {
            let obj = new ScheduledSqlResouceInfo();
            obj.deserialize(params.DstResource)
            this.DstResource = obj;
        }
        this.ScheduledSqlContent = 'ScheduledSqlContent' in params ? params.ScheduledSqlContent : null;
        this.ProcessPeriod = 'ProcessPeriod' in params ? params.ProcessPeriod : null;
        this.ProcessTimeWindow = 'ProcessTimeWindow' in params ? params.ProcessTimeWindow : null;
        this.ProcessDelay = 'ProcessDelay' in params ? params.ProcessDelay : null;
        this.SrcTopicRegion = 'SrcTopicRegion' in params ? params.SrcTopicRegion : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;

    }
}

/**
 * DeleteConfig response structure.
 * @class
 */
class DeleteConfigResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyAlarmShield response structure.
 * @class
 */
class ModifyAlarmShieldResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateDeliverCloudFunction request structure.
 * @class
 */
class CreateDeliverCloudFunctionRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Topic id belonging to the delivery rule
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Cloud Function name for delivery
         * @type {string || null}
         */
        this.FunctionName = null;

        /**
         * Namespace
         * @type {string || null}
         */
        this.Namespace = null;

        /**
         * Function version
         * @type {string || null}
         */
        this.Qualifier = null;

        /**
         * Maximum waiting time for delivery. Unit: seconds
         * @type {number || null}
         */
        this.Timeout = null;

        /**
         * Maximum number of messages to deliver
         * @type {number || null}
         */
        this.MaxMsgNum = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.FunctionName = 'FunctionName' in params ? params.FunctionName : null;
        this.Namespace = 'Namespace' in params ? params.Namespace : null;
        this.Qualifier = 'Qualifier' in params ? params.Qualifier : null;
        this.Timeout = 'Timeout' in params ? params.Timeout : null;
        this.MaxMsgNum = 'MaxMsgNum' in params ? params.MaxMsgNum : null;

    }
}

/**
 * DeleteConsumer request structure.
 * @class
 */
class DeleteConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID bound to the task
         * @type {string || null}
         */
        this.TopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

    }
}

/**
 * QueryRangeMetric response structure.
 * @class
 */
class QueryRangeMetricResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Metric Query Result Type
         * @type {string || null}
         */
        this.ResultType = null;

        /**
         * Metric Query Result
         * @type {string || null}
         */
        this.Result = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ResultType = 'ResultType' in params ? params.ResultType : null;
        this.Result = 'Result' in params ? params.Result : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteIndex request structure.
 * @class
 */
class DeleteIndexRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

    }
}

/**
 * 
 * @class
 */
class AnonymousInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * 
         * @type {Array.<string> || null}
         */
        this.Operations = null;

        /**
         * 
         * @type {Array.<ConditionInfo> || null}
         */
        this.Conditions = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Operations = 'Operations' in params ? params.Operations : null;

        if (params.Conditions) {
            this.Conditions = new Array();
            for (let z in params.Conditions) {
                let obj = new ConditionInfo();
                obj.deserialize(params.Conditions[z]);
                this.Conditions.push(obj);
            }
        }

    }
}

/**
 * Multi-topic search return information
 * @class
 */
class SearchLogTopics extends  AbstractModel {
    constructor(){
        super();

        /**
         * Error information for multi-log topic searchNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<SearchLogErrors> || null}
         */
        this.Errors = null;

        /**
         * Information for each log topic in multi-log topic searchNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<SearchLogInfos> || null}
         */
        this.Infos = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Errors) {
            this.Errors = new Array();
            for (let z in params.Errors) {
                let obj = new SearchLogErrors();
                obj.deserialize(params.Errors[z]);
                this.Errors.push(obj);
            }
        }

        if (params.Infos) {
            this.Infos = new Array();
            for (let z in params.Infos) {
                let obj = new SearchLogInfos();
                obj.deserialize(params.Infos[z]);
                this.Infos.push(obj);
            }
        }

    }
}

/**
 * ModifyConsumer response structure.
 * @class
 */
class ModifyConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeAlertRecordHistory request structure.
 * @class
 */
class DescribeAlertRecordHistoryRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Start time of the query range, which is a Unix timestamp in ms
         * @type {number || null}
         */
        this.From = null;

        /**
         * End time of the query range, which is a Unix timestamp in ms
         * @type {number || null}
         */
        this.To = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Maximum value: 100
         * @type {number || null}
         */
        this.Limit = null;

        /**
         * - alertId: Filter by alarm policy ID. Type: String; optional
- topicId: Filter by ID of monitored object. Type: String; optional
- status: Filter by alarm status. Type: String, optional. Valid values: `0` (uncleared), `1` (cleared), `2` (expired)
- alarmLevel: Filter by alarm severity. Type: String, optional. Valid values: `0` (Warn), `1` (Info), `2` (Critical)

Each request can have up to 10 `Filters` and 100 `Filter.Values`.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.From = 'From' in params ? params.From : null;
        this.To = 'To' in params ? params.To : null;
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }

    }
}

/**
 * DescribeConfigs request structure.
 * @class
 */
class DescribeConfigsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * configName
- Filter by fuzzy match of **collection configuration name**
- Type: String
- Required: No

configId
- Filter by **collection configuration ID**
- Type: String
- Required: No

topicId
- Filter by **log topic**
- Type: String
- Required: No

Each request can contain up to 10 `Filters` and 5 `Filter.Values`.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * Kafka consumer content
 * @class
 */
class KafkaConsumerContent extends  AbstractModel {
    constructor(){
        super();

        /**
         * Consumption data format. Valid values: 0 (original content) and 1 (JSON).
         * @type {number || null}
         */
        this.Format = null;

        /**
         * Whether to ship tag information
This parameter does not need to be set when `Format` is set to `0`.
         * @type {boolean || null}
         */
        this.EnableTag = null;

        /**
         * Metadata information list. Valid values: \_\_SOURCE\_\_, \_\_FILENAME\_\_,
\_\_TIMESTAMP\_\_, \_\_HOSTNAME\_\_, and \_\_PKGID\_\_.
This parameter does not need to be set when `Format` is set to `0`.
         * @type {Array.<string> || null}
         */
        this.MetaFields = null;

        /**
         * Tag data processing mode: 1: Do not tile (default); 2: Tile.

Untiled example:
TAG information: `{"__TAG__":{"fieldA":200,"fieldB":"text"}}`
Untiled: `{"__TAG__":{"fieldA":200,"fieldB":"text"}}`

Tiled example:
TAG information: `{"__TAG__":{"fieldA":200,"fieldB":"text"}}`
Tiled: `{"__TAG__.fieldA":200,"__TAG__.fieldB":"text"}`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.TagTransaction = null;

        /**
         * JSON data format:
1: Not escaped (default format)
2: Escaped

Deliver in JSON format.JsonType is 1: Consistent with the original log, not escaped. Example:
Original log: `{"a":"aa", "b":{"b1":"b1b1", "c1":"c1c1"}}`
Deliver to CKafka: `{"a":"aa", "b":{"b1":"b1b1", "c1":"c1c1"}}`JsonType is 2: escaped. Example:Original log: `{"a":"aa", "b":{"b1":"b1b1", "c1":"c1c1"}}`
Deliver to CKafka: `{"a":"aa","b":"{\"b1\":\"b1b1\", \"c1\":\"c1c1\"}"}`
         * @type {number || null}
         */
        this.JsonType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Format = 'Format' in params ? params.Format : null;
        this.EnableTag = 'EnableTag' in params ? params.EnableTag : null;
        this.MetaFields = 'MetaFields' in params ? params.MetaFields : null;
        this.TagTransaction = 'TagTransaction' in params ? params.TagTransaction : null;
        this.JsonType = 'JsonType' in params ? params.JsonType : null;

    }
}

/**
 * Logset information
 * @class
 */
class LogsetInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Logset name
         * @type {string || null}
         */
        this.LogsetName = null;

        /**
         * Creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Cloud product identifier. If the logset is created by another cloud product, this field returns the name of the cloud product, such as `CDN` or `TKE`.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.AssumerName = null;

        /**
         * Tag bound to logset
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Number of log topics in logset
         * @type {number || null}
         */
        this.TopicCount = null;

        /**
         * If `AssumerName` is not empty, it indicates the service provider who creates the logset.
         * @type {string || null}
         */
        this.RoleName = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.LogsetName = 'LogsetName' in params ? params.LogsetName : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.AssumerName = 'AssumerName' in params ? params.AssumerName : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.TopicCount = 'TopicCount' in params ? params.TopicCount : null;
        this.RoleName = 'RoleName' in params ? params.RoleName : null;

    }
}

/**
 * DescribeConsumer request structure.
 * @class
 */
class DescribeConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID bound to the task
         * @type {string || null}
         */
        this.TopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

    }
}

/**
 * DeleteConfig request structure.
 * @class
 */
class DeleteConfigRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection rule configuration ID
         * @type {string || null}
         */
        this.ConfigId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ConfigId = 'ConfigId' in params ? params.ConfigId : null;

    }
}

/**
 * Multi-Dimensional analysis dimension
 * @class
 */
class AnalysisDimensional extends  AbstractModel {
    constructor(){
        super();

        /**
         * Analysis name
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Type of data being analyzed. Valid values: `query`, `field`, `original`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Analysis content
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Content = null;

        /**
         * Multi-dimensional analysis configuration.

Supported when the type field of Analysis is query (custom){
"Key": "SyntaxRule", // Syntax rules"Value": "1" // 0: Lucene syntax, 1: CQL syntax}

Supported when the Type field of Analysis is field (top5) {
    "Key": "QueryIndex",
"Value": "-1" // -1: Custom, 1: Execute Statement 1, 2: Execute Statement 2},{
"Key": "CustomQuery", // Search statement. Valid and required when QueryIndex is -1    "Value": "* | select count(*) as count"
},{
"Key": "SyntaxRule", // If this field cannot be found, it's assumed to be the legacy syntax (Lucene)
    "Value": "0"//0:Lucene, 1:CQL
}       

When the Type field of Analysis is original (original log), it supports
{
    "Key": "Fields",
    "Value": "__SOURCE__,__HOSTNAME__,__TIMESTAMP__,__PKG_LOGID__,__TAG__.pod_ip"
}, {
    "Key": "QueryIndex",
"Value": "-1" // -1: Custom, 1: Execute Statement 1, 2: Execute Statement 2},{
"Key": "CustomQuery", // //Search statement. Valid and required when QueryIndex is -1    "Value": "* | select count(*) as count"
},{
"Key": "Format", // Display format. 1: One log per line, 2: One field per line for each log    "Value": "2"
},
{
"Key": "Limit", // Maximum number of logs    "Value": "5"
},{
"Key": "SyntaxRule", // If this field cannot be found, it's considered the legacy syntax
    "Value": "0"//0:Lucene, 1:CQL
}
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<AlarmAnalysisConfig> || null}
         */
        this.ConfigInfo = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;
        this.Type = 'Type' in params ? params.Type : null;
        this.Content = 'Content' in params ? params.Content : null;

        if (params.ConfigInfo) {
            this.ConfigInfo = new Array();
            for (let z in params.ConfigInfo) {
                let obj = new AlarmAnalysisConfig();
                obj.deserialize(params.ConfigInfo[z]);
                this.ConfigInfo.push(obj);
            }
        }

    }
}

/**
 * Log import rule
 * @class
 */
class LogRechargeRuleInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Import type. Valid values: `json_log` (JSON logs), `minimalist_log` (single-line full text), and fullregex_log (single-line full regex)
         * @type {string || null}
         */
        this.RechargeType = null;

        /**
         * Encoding format. Valid values: 0 (default, UTF-8) and 1 GBK).
         * @type {number || null}
         */
        this.EncodingFormat = null;

        /**
         * Whether to use the default time. Valid values: `true` (default) and `false`.
         * @type {boolean || null}
         */
        this.DefaultTimeSwitch = null;

        /**
         * Full log matching rule, which is valid only if `RechargeType` is `fullregex_log`.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogRegex = null;

        /**
         * Whether to upload the logs that failed to be parsed. Valid values: `true` and `false`.
         * @type {boolean || null}
         */
        this.UnMatchLogSwitch = null;

        /**
         * Key of the log that failed to be parsed
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UnMatchLogKey = null;

        /**
         * Time source of the log that failed to be parsed. Valid values: 0 (current system time) and 1 (Kafka message timestamp).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.UnMatchLogTimeSrc = null;

        /**
         * Default time source. Valid values: 0 (current system time) and 1 (Kafka message timestamp).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.DefaultTimeSrc = null;

        /**
         * Time field
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TimeKey = null;

        /**
         * Time regular expression
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TimeRegex = null;

        /**
         * Time field format
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TimeFormat = null;

        /**
         * Time zone
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TimeZone = null;

        /**
         * Metadata information. Kafka supports import of kafka_topic, kafka_partition, kafka_offset, and kafka_timestamp.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.Metadata = null;

        /**
         * List of log keys, which is required when `RechargeType` is set to `full_regex_log`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.Keys = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RechargeType = 'RechargeType' in params ? params.RechargeType : null;
        this.EncodingFormat = 'EncodingFormat' in params ? params.EncodingFormat : null;
        this.DefaultTimeSwitch = 'DefaultTimeSwitch' in params ? params.DefaultTimeSwitch : null;
        this.LogRegex = 'LogRegex' in params ? params.LogRegex : null;
        this.UnMatchLogSwitch = 'UnMatchLogSwitch' in params ? params.UnMatchLogSwitch : null;
        this.UnMatchLogKey = 'UnMatchLogKey' in params ? params.UnMatchLogKey : null;
        this.UnMatchLogTimeSrc = 'UnMatchLogTimeSrc' in params ? params.UnMatchLogTimeSrc : null;
        this.DefaultTimeSrc = 'DefaultTimeSrc' in params ? params.DefaultTimeSrc : null;
        this.TimeKey = 'TimeKey' in params ? params.TimeKey : null;
        this.TimeRegex = 'TimeRegex' in params ? params.TimeRegex : null;
        this.TimeFormat = 'TimeFormat' in params ? params.TimeFormat : null;
        this.TimeZone = 'TimeZone' in params ? params.TimeZone : null;
        this.Metadata = 'Metadata' in params ? params.Metadata : null;
        this.Keys = 'Keys' in params ? params.Keys : null;

    }
}

/**
 * CloseKafkaConsumer request structure.
 * @class
 */
class CloseKafkaConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.FromTopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.FromTopicId = 'FromTopicId' in params ? params.FromTopicId : null;

    }
}

/**
 * Metafield index configuration
 * @class
 */
class RuleTagInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Case sensitivity
         * @type {boolean || null}
         */
        this.CaseSensitive = null;

        /**
         * Field information in the metafield index configuration
         * @type {Array.<KeyValueInfo> || null}
         */
        this.KeyValues = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.CaseSensitive = 'CaseSensitive' in params ? params.CaseSensitive : null;

        if (params.KeyValues) {
            this.KeyValues = new Array();
            for (let z in params.KeyValues) {
                let obj = new KeyValueInfo();
                obj.deserialize(params.KeyValues[z]);
                this.KeyValues.push(obj);
            }
        }

    }
}

/**
 * CreateExport request structure.
 * @class
 */
class CreateExportRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Number of logs to be exported. Maximum value: 50 million
         * @type {number || null}
         */
        this.Count = null;

        /**
         * Search statements for log export. <a href="https://intl.cloud.tencent.com/document/product/614/44061?from_cn_redirect=1" target="_blank">[SQL statements]</a> are not supported.
         * @type {string || null}
         */
        this.Query = null;

        /**
         * Start time of the log to be exported, which is a timestamp in milliseconds
         * @type {number || null}
         */
        this.From = null;

        /**
         * End time of the log to be exported, which is a timestamp in milliseconds
         * @type {number || null}
         */
        this.To = null;

        /**
         * Exported log sorting order by time. Valid values: `asc`: ascending; `desc`: descending. Default value: `desc`
         * @type {string || null}
         */
        this.Order = null;

        /**
         * Exported log data format. Valid values: `json`, `csv`. Default value: `json`
         * @type {string || null}
         */
        this.Format = null;

        /**
         * Syntax rules; the default value is 0.0: Lucene syntax; 1: CQL syntax.
         * @type {number || null}
         */
        this.SyntaxRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Count = 'Count' in params ? params.Count : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.From = 'From' in params ? params.From : null;
        this.To = 'To' in params ? params.To : null;
        this.Order = 'Order' in params ? params.Order : null;
        this.Format = 'Format' in params ? params.Format : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;

    }
}

/**
 * QueryRangeMetric request structure.
 * @class
 */
class QueryRangeMetricRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Metric Topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Queries statements; using PromQL syntax
         * @type {string || null}
         */
        this.Query = null;

        /**
         * Queries start time; unix timestamp in seconds
         * @type {number || null}
         */
        this.Start = null;

        /**
         * Queries end time; unix timestamp in seconds
         * @type {number || null}
         */
        this.End = null;

        /**
         * Queries time interval, in seconds
         * @type {number || null}
         */
        this.Step = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.Start = 'Start' in params ? params.Start : null;
        this.End = 'End' in params ? params.End : null;
        this.Step = 'Step' in params ? params.Step : null;

    }
}

/**
 * DescribeAlarmNotices response structure.
 * @class
 */
class DescribeAlarmNoticesResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm notification template list
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<AlarmNotice> || null}
         */
        this.AlarmNotices = null;

        /**
         * Total number of eligible alarm notification templates
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.AlarmNotices) {
            this.AlarmNotices = new Array();
            for (let z in params.AlarmNotices) {
                let obj = new AlarmNotice();
                obj.deserialize(params.AlarmNotices[z]);
                this.AlarmNotices.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteDataTransform request structure.
 * @class
 */
class DeleteDataTransformRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Data processing task ID
         * @type {string || null}
         */
        this.TaskId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;

    }
}

/**
 * DescribeMachineGroups response structure.
 * @class
 */
class DescribeMachineGroupsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group information list
Note: This field may return "null", indicating that no valid values can be obtained.
         * @type {Array.<MachineGroupInfo> || null}
         */
        this.MachineGroups = null;

        /**
         * Total number of pages
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.MachineGroups) {
            this.MachineGroups = new Array();
            for (let z in params.MachineGroups) {
                let obj = new MachineGroupInfo();
                obj.deserialize(params.MachineGroups[z]);
                this.MachineGroups.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyConfig request structure.
 * @class
 */
class ModifyConfigRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection rule configuration ID, accessed through [Access collection rule configuration](https://intl.cloud.tencent.com/document/product/614/58616?from_cn_redirect=1).
         * @type {string || null}
         */
        this.ConfigId = null;

        /**
         * Collection rule configuration name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Log collection path containing the filename
         * @type {string || null}
         */
        this.Path = null;

        /**
         * The types of logs collected. Supported types are:
- json_log: JSON File Log (For more information, see [Using JSON pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17419?from_cn_redirect=1));- delimiter_log: Delimiter - File Logs (For more information, see [Using delimiter pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17420?from_cn_redirect=1));- minimalist_log: Single-line Full-text File Log (For more information, see [Using single-line full-text pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17421?from_cn_redirect=1));- fullregex_log: Single line full regular expression - File log (For more information, see [Using single-line - complete regular expression pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/52365?from_cn_redirect=1));- multiline_log: Multiline Full-text File Log (For more information, see [Using multi-line full-text pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17422?from_cn_redirect=1));- multiline_fullregex_log: Multi-line complete regular expression - File Logs (For more information, see [Using multi-line - complete regular expression pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/52366?from_cn_redirect=1));- user_define_log: Combined parsing (Suitable for logs with multiple nested formats, see [Using combined parsing pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/61310?from_cn_redirect=1));- service_syslog: syslog collection (For more information, see [Collect Syslog](https://intl.cloud.tencent.com/document/product/614/81454?from_cn_redirect=1));- windows_event_log: Windows event log (For more information, see [Collect Windows Event Log](https://intl.cloud.tencent.com/document/product/614/96678?from_cn_redirect=1)).
         * @type {string || null}
         */
        this.LogType = null;

        /**
         * Extraction rule. If `ExtractRule` is set, `LogType` must be set.
         * @type {ExtractRuleInfo || null}
         */
        this.ExtractRule = null;

        /**
         * Collection path blocklist
         * @type {Array.<ExcludePathInfo> || null}
         */
        this.ExcludePaths = null;

        /**
         * Log topic (TopicId) associated with collection configuration
         * @type {string || null}
         */
        this.Output = null;

        /**
         * Custom parsing string, serialized as a JSON string.
         * @type {string || null}
         */
        this.UserDefineRule = null;

        /**
         * Advanced collection configuration. A JSON string, Key/Value definition as follows:
- ClsAgentFileTimeout (timeout property), value range: an integer greater than or equal to 0, where 0 means no timeout- ClsAgentMaxDepth (maximum directory depth), value range: an integer greater than or equal to 0
- ClsAgentParseFailMerge (merge logs that failed parsing), value range: true or false
Sample:
`{\"ClsAgentFileTimeout\":0,\"ClsAgentMaxDepth\":10,\"ClsAgentParseFailMerge\":true}`
         * @type {string || null}
         */
        this.AdvancedConfig = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ConfigId = 'ConfigId' in params ? params.ConfigId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.Path = 'Path' in params ? params.Path : null;
        this.LogType = 'LogType' in params ? params.LogType : null;

        if (params.ExtractRule) {
            let obj = new ExtractRuleInfo();
            obj.deserialize(params.ExtractRule)
            this.ExtractRule = obj;
        }

        if (params.ExcludePaths) {
            this.ExcludePaths = new Array();
            for (let z in params.ExcludePaths) {
                let obj = new ExcludePathInfo();
                obj.deserialize(params.ExcludePaths[z]);
                this.ExcludePaths.push(obj);
            }
        }
        this.Output = 'Output' in params ? params.Output : null;
        this.UserDefineRule = 'UserDefineRule' in params ? params.UserDefineRule : null;
        this.AdvancedConfig = 'AdvancedConfig' in params ? params.AdvancedConfig : null;

    }
}

/**
 * AddMachineGroupInfo request structure.
 * @class
 */
class AddMachineGroupInfoRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

        /**
         * Machine group type
Supported types: `ip` and `label`
         * @type {MachineGroupTypeInfo || null}
         */
        this.MachineGroupType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;

        if (params.MachineGroupType) {
            let obj = new MachineGroupTypeInfo();
            obj.deserialize(params.MachineGroupType)
            this.MachineGroupType = obj;
        }

    }
}

/**
 * DescribeKafkaRecharges request structure.
 * @class
 */
class DescribeKafkaRechargesRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Import configuration ID
         * @type {string || null}
         */
        this.Id = null;

        /**
         * Status. Valid values: 1 (running) and 2 (suspended).
         * @type {number || null}
         */
        this.Status = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Id = 'Id' in params ? params.Id : null;
        this.Status = 'Status' in params ? params.Status : null;

    }
}

/**
 * JSON type description
 * @class
 */
class JsonInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Enablement flag
         * @type {boolean || null}
         */
        this.EnableTag = null;

        /**
         * List of metadata. Supported metadata types: __SOURCE__, __FILENAME__, __TIMESTAMP__, __HOSTNAME__.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.MetaFields = null;

        /**
         * JSON format for shipping. `0`: String format; `1`: Structured format.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.JsonType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.EnableTag = 'EnableTag' in params ? params.EnableTag : null;
        this.MetaFields = 'MetaFields' in params ? params.MetaFields : null;
        this.JsonType = 'JsonType' in params ? params.JsonType : null;

    }
}

/**
 * PreviewKafkaRecharge response structure.
 * @class
 */
class PreviewKafkaRechargeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log sample, which is returned when `PreviewType` is set to `2`
         * @type {string || null}
         */
        this.LogSample = null;

        /**
         * Log preview result
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogData = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogSample = 'LogSample' in params ? params.LogSample : null;
        this.LogData = 'LogData' in params ? params.LogData : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateShipper request structure.
 * @class
 */
class CreateShipperRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * ID of the log topic to which the shipping rule to be created belongs
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Destination bucket in the shipping rule to be created
         * @type {string || null}
         */
        this.Bucket = null;

        /**
         * Prefix of the shipping directory in the shipping rule to be created
         * @type {string || null}
         */
        this.Prefix = null;

        /**
         * Shipping rule name
         * @type {string || null}
         */
        this.ShipperName = null;

        /**
         * Interval between shipping tasks (in sec). Default value: 300. Value range: 300-900
         * @type {number || null}
         */
        this.Interval = null;

        /**
         * Maximum size of a file to be shipped, in MB. Default value: 256. Value range: 5-256
         * @type {number || null}
         */
        this.MaxSize = null;

        /**
         * Filter rules for shipped logs. Only logs matching the rules can be shipped. All rules are in the AND relationship, and up to five rules can be added. If the array is empty, no filtering will be performed, and all logs will be shipped.
         * @type {Array.<FilterRuleInfo> || null}
         */
        this.FilterRules = null;

        /**
         * Rules for partitioning logs to be shipped. `strftime` can be used to define the presentation of time format.
         * @type {string || null}
         */
        this.Partition = null;

        /**
         * Compression configuration of shipped log
         * @type {CompressInfo || null}
         */
        this.Compress = null;

        /**
         * Format configuration of shipped log content
         * @type {ContentInfo || null}
         */
        this.Content = null;

        /**
         * Naming a shipping file. Valid values: `0` (by random number); `1` (by shipping time). Default value: `0`.
         * @type {number || null}
         */
        this.FilenameMode = null;

        /**
         * Start time for data shipping, which cannot be earlier than the lifecycle start time of the log topic. If you do not specify this parameter, it will be set to the time when you create the data shipping task.
         * @type {number || null}
         */
        this.StartTime = null;

        /**
         * End time for data shipping, which cannot be set to a future time. If you do not specify this parameter, it indicates continuous data shipping.
         * @type {number || null}
         */
        this.EndTime = null;

        /**
         * COS bucket storage type
         * @type {string || null}
         */
        this.StorageType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Bucket = 'Bucket' in params ? params.Bucket : null;
        this.Prefix = 'Prefix' in params ? params.Prefix : null;
        this.ShipperName = 'ShipperName' in params ? params.ShipperName : null;
        this.Interval = 'Interval' in params ? params.Interval : null;
        this.MaxSize = 'MaxSize' in params ? params.MaxSize : null;

        if (params.FilterRules) {
            this.FilterRules = new Array();
            for (let z in params.FilterRules) {
                let obj = new FilterRuleInfo();
                obj.deserialize(params.FilterRules[z]);
                this.FilterRules.push(obj);
            }
        }
        this.Partition = 'Partition' in params ? params.Partition : null;

        if (params.Compress) {
            let obj = new CompressInfo();
            obj.deserialize(params.Compress)
            this.Compress = obj;
        }

        if (params.Content) {
            let obj = new ContentInfo();
            obj.deserialize(params.Content)
            this.Content = obj;
        }
        this.FilenameMode = 'FilenameMode' in params ? params.FilenameMode : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;
        this.StorageType = 'StorageType' in params ? params.StorageType : null;

    }
}

/**
 * CreateTopic response structure.
 * @class
 */
class CreateTopicResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteAlarm response structure.
 * @class
 */
class DeleteAlarmResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Callback address
 * @class
 */
class WebCallback extends  AbstractModel {
    constructor(){
        super();

        /**
         * Callback address
         * @type {string || null}
         */
        this.Url = null;

        /**
         * Callback type. Valid values:
<li> WeCom
<li> Http
         * @type {string || null}
         */
        this.CallbackType = null;

        /**
         * Callback method. Valid values:
<li> POST
<li> PUT
Default value: `POST`. This parameter is required if `CallbackType` is `Http`.
Note: This field may return `null`, indicating that no valid value was found.
         * @type {string || null}
         */
        this.Method = null;

        /**
         * Request header
Note: This parameter is disused. To specify request headers, see `CallBack` in <a href="https://intl.cloud.tencent.com/document/product/614/56466?from_cn_redirect=1">CreateAlarmNotice</a>.
Note: This field may return `null`, indicating that no valid value was found.
         * @type {Array.<string> || null}
         */
        this.Headers = null;

        /**
         * Request content
Note: This parameter is disused. To specify request content, see `CallBack` in <a href="https://intl.cloud.tencent.com/document/product/614/56466?from_cn_redirect=1">CreateAlarmNotice</a>.
Note: This field may return `null`, indicating that no valid value was found.
         * @type {string || null}
         */
        this.Body = null;

        /**
         * Number
         * @type {number || null}
         */
        this.Index = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Url = 'Url' in params ? params.Url : null;
        this.CallbackType = 'CallbackType' in params ? params.CallbackType : null;
        this.Method = 'Method' in params ? params.Method : null;
        this.Headers = 'Headers' in params ? params.Headers : null;
        this.Body = 'Body' in params ? params.Body : null;
        this.Index = 'Index' in params ? params.Index : null;

    }
}

/**
 * DescribeAlarms response structure.
 * @class
 */
class DescribeAlarmsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm policy list
         * @type {Array.<AlarmInfo> || null}
         */
        this.Alarms = null;

        /**
         * Number of eligible alarm policies
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Alarms) {
            this.Alarms = new Array();
            for (let z in params.Alarms) {
                let obj = new AlarmInfo();
                obj.deserialize(params.Alarms[z]);
                this.Alarms.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateAlarmNotice response structure.
 * @class
 */
class CreateAlarmNoticeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm template ID
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyTopic response structure.
 * @class
 */
class ModifyTopicResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateConfig request structure.
 * @class
 */
class CreateConfigRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection configuration name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Log topic ID (TopicId) of collection configuration
         * @type {string || null}
         */
        this.Output = null;

        /**
         * Log collection path containing the filename
         * @type {string || null}
         */
        this.Path = null;

        /**
         * The collected log type, default is minimalist_log. Supports the following types:- json_log: JSON File Log (For more information, see [Using JSON pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17419?from_cn_redirect=1));- delimiter_log: Delimiter - File Logs (For more information, see [Using delimiter pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17420?from_cn_redirect=1));- minimalist_log: Single-line Full-text File Log (For more information, see [Using single-line full-text pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17421?from_cn_redirect=1));- fullregex_log: Single line full regular expression - File log (For more information, see [Using single-line - complete regular expression pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/52365?from_cn_redirect=1));- multiline_log: Multiline Full-text File Log (For more information, see [Using multi-line full-text pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/17422?from_cn_redirect=1));- multiline_fullregex_log: Multi-line complete regular expression - File Logs (For more information, see [Using multi-line - complete regular expression pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/52366?from_cn_redirect=1));- user_define_log: Combined parsing (Suitable for logs with multiple nested formats, see [Using combined parsing pattern to collect logs](https://intl.cloud.tencent.com/document/product/614/61310?from_cn_redirect=1));- service_syslog: syslog collection (For more information, see [Collect Syslog](https://intl.cloud.tencent.com/document/product/614/81454?from_cn_redirect=1));- windows_event_log: Windows event log (see [Collecting Windows Event Logs](https://intl.cloud.tencent.com/document/product/614/96678?from_cn_redirect=1)).
         * @type {string || null}
         */
        this.LogType = null;

        /**
         * Extraction rule. If `ExtractRule` is set, `LogType` must be set.
         * @type {ExtractRuleInfo || null}
         */
        this.ExtractRule = null;

        /**
         * Collection path blocklist
         * @type {Array.<ExcludePathInfo> || null}
         */
        this.ExcludePaths = null;

        /**
         * Custom collection rules, serialized JSON string. Required when LogType is user_define_log.
         * @type {string || null}
         */
        this.UserDefineRule = null;

        /**
         * Advanced collection configuration. A JSON string, Key/Value definition as follows:- ClsAgentFileTimeout (timeout property), value range: an integer greater than or equal to 0, where 0 means no timeout.- ClsAgentMaxDepth (maximum directory depth), value range: an integer greater than or equal to 0.- `ClsAgentParseFailMerge` (Merge Parsing Failure Log), value range: true or false
Sample:`{\"ClsAgentFileTimeout\":0,\"ClsAgentMaxDepth\":10,\"ClsAgentParseFailMerge\":true}`

Default placeholder value in console: `{\"ClsAgentDefault\":0}`
         * @type {string || null}
         */
        this.AdvancedConfig = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;
        this.Output = 'Output' in params ? params.Output : null;
        this.Path = 'Path' in params ? params.Path : null;
        this.LogType = 'LogType' in params ? params.LogType : null;

        if (params.ExtractRule) {
            let obj = new ExtractRuleInfo();
            obj.deserialize(params.ExtractRule)
            this.ExtractRule = obj;
        }

        if (params.ExcludePaths) {
            this.ExcludePaths = new Array();
            for (let z in params.ExcludePaths) {
                let obj = new ExcludePathInfo();
                obj.deserialize(params.ExcludePaths[z]);
                this.ExcludePaths.push(obj);
            }
        }
        this.UserDefineRule = 'UserDefineRule' in params ? params.UserDefineRule : null;
        this.AdvancedConfig = 'AdvancedConfig' in params ? params.AdvancedConfig : null;

    }
}

/**
 * CreateShipper response structure.
 * @class
 */
class CreateShipperResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping task ID.
         * @type {string || null}
         */
        this.ShipperId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ShipperId = 'ShipperId' in params ? params.ShipperId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeKafkaRecharges response structure.
 * @class
 */
class DescribeKafkaRechargesResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * KafkaRechargeInfo list
         * @type {Array.<KafkaRechargeInfo> || null}
         */
        this.Infos = null;

        /**
         * Total Kafka data records imported
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Infos) {
            this.Infos = new Array();
            for (let z in params.Infos) {
                let obj = new KafkaRechargeInfo();
                obj.deserialize(params.Infos[z]);
                this.Infos.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteIndex response structure.
 * @class
 */
class DeleteIndexResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Alarm configuration for the multidimensional analysis
 * @class
 */
class AlarmAnalysisConfig extends  AbstractModel {
    constructor(){
        super();

        /**
         * Keys. The following keys are supported:
SyntaxRule: Syntax rule, value supports 0: Lucene syntax; 1: CQL syntax.
QueryIndex: Serial number of execution statement. Value supports -1: Custom; 1: Execute Statement 1; 2: Execute Statement 2.CustomQuery: Search statement. Valid and required when QueryIndex is -1, example of value: "* | select count(*) as count".Fields: Fields. Value supports __SOURCE__; __FILENAME__; __HOSTNAME__; __TIMESTAMP__; __INDEX_STATUS__; __PKG_LOGID__; __TOPIC__.
Format: Display format. Value supports 1: One log per line; 2: One field per line per log.
Limit: Maximum number of logs. Example of value: 5.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Value.
Key corresponds to the following values:
SyntaxRule: Syntax rule, value supports 0: Lucene syntax; 1: CQL syntax.
QueryIndex: Serial number of execution statement. Value supports -1: Custom; 1: Execute Statement 1; 2: Execute Statement 2.CustomQuery: Search statement. Valid and required when QueryIndex is -1, example of value: "* | select count(*) as count".Fields: Fields. Value supports __SOURCE__; __FILENAME__; __HOSTNAME__; __TIMESTAMP__; __INDEX_STATUS__; __PKG_LOGID__; __TOPIC__.Format: Display format. Value supports 1: One log per line; 2: One field per line per log.Limit: Maximum number of logs. Example of value: 5.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * Error information for multi-log topic search
 * @class
 */
class SearchLogErrors extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic IDNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Error MessageNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.ErrorMsg = null;

        /**
         * Error CodeNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.ErrorCodeStr = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.ErrorMsg = 'ErrorMsg' in params ? params.ErrorMsg : null;
        this.ErrorCodeStr = 'ErrorCodeStr' in params ? params.ErrorCodeStr : null;

    }
}

/**
 * ModifyIndex request structure.
 * @class
 */
class ModifyIndexRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * It does not take effect by default
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Index rule
         * @type {RuleInfo || null}
         */
        this.Rule = null;

        /**
         * Whether full-text indexing includes internal fields (`__FILENAME__`, `__HOSTNAME__`, and `__SOURCE__`). Default value: `false`. Recommended value: `true`.
* `false`: Full-text indexing does not include internal fields.
* `true`: Full-text indexing includes internal fields.
         * @type {boolean || null}
         */
        this.IncludeInternalFields = null;

        /**
         * Whether full-text indexing includes metadata fields (which are prefixed with `__TAG__`). Default value: `0`. Recommended value: `1`.
* `0`: Full-text indexing includes only metadata fields with key-value indexing enabled.
* `1`: Full-text indexing includes all metadata fields.
* `2`: Full-text indexing does not include metadata fields.
         * @type {number || null}
         */
        this.MetadataFlag = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Status = 'Status' in params ? params.Status : null;

        if (params.Rule) {
            let obj = new RuleInfo();
            obj.deserialize(params.Rule)
            this.Rule = obj;
        }
        this.IncludeInternalFields = 'IncludeInternalFields' in params ? params.IncludeInternalFields : null;
        this.MetadataFlag = 'MetadataFlag' in params ? params.MetadataFlag : null;

    }
}

/**
 * Column attribute of log analysis
 * @class
 */
class Column extends  AbstractModel {
    constructor(){
        super();

        /**
         * Column name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Column attribute
         * @type {string || null}
         */
        this.Type = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;
        this.Type = 'Type' in params ? params.Type : null;

    }
}

/**
 * Format configuration of shipped log content
 * @class
 */
class ContentInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Content format. Valid values: `json`, `csv`
         * @type {string || null}
         */
        this.Format = null;

        /**
         * CSV format content description
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {CsvInfo || null}
         */
        this.Csv = null;

        /**
         * JSON format content description
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {JsonInfo || null}
         */
        this.Json = null;

        /**
         * `Parquet` format description
Note: This field may return `null`, indicating that no valid value can be obtained.
         * @type {ParquetInfo || null}
         */
        this.Parquet = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Format = 'Format' in params ? params.Format : null;

        if (params.Csv) {
            let obj = new CsvInfo();
            obj.deserialize(params.Csv)
            this.Csv = obj;
        }

        if (params.Json) {
            let obj = new JsonInfo();
            obj.deserialize(params.Json)
            this.Json = obj;
        }

        if (params.Parquet) {
            let obj = new ParquetInfo();
            obj.deserialize(params.Parquet)
            this.Parquet = obj;
        }

    }
}

/**
 * Index description information of the field for which key-value index needs to be enabled
 * @class
 */
class ValueInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Field type. Valid values: `long`, `text`, `double`
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Separator of fields. Each character represents a separator.
Only symbols, \n\t\r, and escape character \ are supported.
`long` and `double` fields need to be null.
Note: \n\t\r can be directly enclosed in double quotes as the input parameter without escaping. When debugging with API Explorer, use the JSON parameter input method to avoid repeated escaping of \n\t\r.
         * @type {string || null}
         */
        this.Tokenizer = null;

        /**
         * Whether the analysis feature is enabled for the field
         * @type {boolean || null}
         */
        this.SqlFlag = null;

        /**
         * Whether Chinese characters are contained. For `long` and `double` fields, set them to `false`.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.ContainZH = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Type = 'Type' in params ? params.Type : null;
        this.Tokenizer = 'Tokenizer' in params ? params.Tokenizer : null;
        this.SqlFlag = 'SqlFlag' in params ? params.SqlFlag : null;
        this.ContainZH = 'ContainZH' in params ? params.ContainZH : null;

    }
}

/**
 * DescribeDataTransformInfo request structure.
 * @class
 */
class DescribeDataTransformInfoRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * <br><li>taskName

Filter by **processing task name**.
Type: String

Required: No

<br><li>taskId

Filter by **processing task ID**.
Type: String

Required: No

<br><li>srctopicId

Filter by **source topic ID**.
Type: String

Required: No

Each request can have up to 10 `Filters` and 100 `Filter.Values`.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * The pagination offset. Default value: 0.
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100.
         * @type {number || null}
         */
        this.Limit = null;

        /**
         * Task type. Valid values: 1: Get the details of a single task. 2 (default): Get the task list.
         * @type {number || null}
         */
        this.Type = null;

        /**
         * Task ID, which is required when `Type` is set to `1`
         * @type {string || null}
         */
        this.TaskId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;
        this.Type = 'Type' in params ? params.Type : null;
        this.TaskId = 'TaskId' in params ? params.TaskId : null;

    }
}

/**
 * DeleteShipper response structure.
 * @class
 */
class DeleteShipperResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Log export information
 * @class
 */
class ExportInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Log export task ID
         * @type {string || null}
         */
        this.ExportId = null;

        /**
         * Log export query statement
         * @type {string || null}
         */
        this.Query = null;

        /**
         * Log export filename
         * @type {string || null}
         */
        this.FileName = null;

        /**
         * Log file size
         * @type {number || null}
         */
        this.FileSize = null;

        /**
         * Log export time sorting
         * @type {string || null}
         */
        this.Order = null;

        /**
         * Log export format
         * @type {string || null}
         */
        this.Format = null;

        /**
         * Number of logs to be exported
         * @type {number || null}
         */
        this.Count = null;

        /**
         * Log download status. Valid values: `Processing`, `Completed`, `Failed`, `Expired` (three-day validity period), and `Queuing`.
         * @type {string || null}
         */
        this.Status = null;

        /**
         * Log export start time
         * @type {number || null}
         */
        this.From = null;

        /**
         * Log export end time
         * @type {number || null}
         */
        this.To = null;

        /**
         * Log export path, valid for one hour. Please download using this path as soon as possible.
         * @type {string || null}
         */
        this.CosPath = null;

        /**
         * Log export creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Syntax rules. The default value is 0.0: Lucene syntax, 1: CQL syntax.
         * @type {number || null}
         */
        this.SyntaxRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.ExportId = 'ExportId' in params ? params.ExportId : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.FileName = 'FileName' in params ? params.FileName : null;
        this.FileSize = 'FileSize' in params ? params.FileSize : null;
        this.Order = 'Order' in params ? params.Order : null;
        this.Format = 'Format' in params ? params.Format : null;
        this.Count = 'Count' in params ? params.Count : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.From = 'From' in params ? params.From : null;
        this.To = 'To' in params ? params.To : null;
        this.CosPath = 'CosPath' in params ? params.CosPath : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;

    }
}

/**
 * ModifyIndex response structure.
 * @class
 */
class ModifyIndexResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Basic Topic Information
 * @class
 */
class TopicInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         *  Topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Topic Name
         * @type {string || null}
         */
        this.TopicName = null;

        /**
         * Number of topic partitions
         * @type {number || null}
         */
        this.PartitionCount = null;

        /**
         * Whether the topic has indexing enabled (the topic type must be log topic)
         * @type {boolean || null}
         */
        this.Index = null;

        /**
         * Cloud product identifier. When the topic is created by other cloud products, this field displays the name of the cloud product, such as CDN, TKE.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.AssumerName = null;

        /**
         * Creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Whether the topic has log collection enabled. true: collection enabled; false: collection disabled.Log collection is enabled by default when creating a log topic, and this field can be modified by calling ModifyTopic through the SDK.The console currently does not support modifying this parameter.
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Tag information bound to the topicNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Whether automatic split is enabled for this topic
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.AutoSplit = null;

        /**
         * Maximum number of partitions to split into for this topic if automatic split is enabled
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.MaxSplitPartitions = null;

        /**
         * Storage type of the topicNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.StorageType = null;

        /**
         * Lifecycle in days. Value range: 1-3600 (3640 indicates permanent retention)
Note: This field may return `null`, indicating that no valid value was found.
         * @type {number || null}
         */
        this.Period = null;

        /**
         * Cloud product sub-identifier. If the log topic is created by another cloud product, this field returns the name of the cloud product and its log type, such as `TKE-Audit` or `TKE-Event`. Some products only return the cloud product identifier (`AssumerName`), without this field.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.SubAssumerName = null;

        /**
         * Topic description
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Describes = null;

        /**
         * Enable log sinking, with the lifecycle of standard storage, where hotPeriod < Period.For standard storage, hotPeriod is used, and for infrequent access storage, it is Period-hotPeriod. (The topic type must be a log topic)HotPeriod=0 indicates that log sinking is not enabled.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.HotPeriod = null;

        /**
         * Topic type.
- 0:  log  Topic  
- 1: Metric Topic
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.BizType = null;

        /**
         * Free authentication switch. false: disabled; true: enabled.After enabling, anonymous access to the log topic will be supported for specified operations. For details, please refer to Log Topic (https://intl.cloud.tencent.com/document/product/614/41035?from_cn_redirect=1).Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.IsWebTracking = null;

        /**
         * 
         * @type {TopicExtendInfo || null}
         */
        this.Extends = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.TopicName = 'TopicName' in params ? params.TopicName : null;
        this.PartitionCount = 'PartitionCount' in params ? params.PartitionCount : null;
        this.Index = 'Index' in params ? params.Index : null;
        this.AssumerName = 'AssumerName' in params ? params.AssumerName : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.Status = 'Status' in params ? params.Status : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.AutoSplit = 'AutoSplit' in params ? params.AutoSplit : null;
        this.MaxSplitPartitions = 'MaxSplitPartitions' in params ? params.MaxSplitPartitions : null;
        this.StorageType = 'StorageType' in params ? params.StorageType : null;
        this.Period = 'Period' in params ? params.Period : null;
        this.SubAssumerName = 'SubAssumerName' in params ? params.SubAssumerName : null;
        this.Describes = 'Describes' in params ? params.Describes : null;
        this.HotPeriod = 'HotPeriod' in params ? params.HotPeriod : null;
        this.BizType = 'BizType' in params ? params.BizType : null;
        this.IsWebTracking = 'IsWebTracking' in params ? params.IsWebTracking : null;

        if (params.Extends) {
            let obj = new TopicExtendInfo();
            obj.deserialize(params.Extends)
            this.Extends = obj;
        }

    }
}

/**
 * Condition of triggering by group
 * @class
 */
class GroupTriggerConditionInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Name of the field for triggering by group
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Value of the field for triggering by group
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * DescribeLogContext response structure.
 * @class
 */
class DescribeLogContextResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log context information set
         * @type {Array.<LogContextInfo> || null}
         */
        this.LogContextInfos = null;

        /**
         * Whether the previous logs have been fully returned (PrevOver is false indicates that some previous logs are yet to be returned).
         * @type {boolean || null}
         */
        this.PrevOver = null;

        /**
         * Whether the subsequent logs have been fully returned (NextOver is false indicates that some subsequent logs are yet to be returned).
         * @type {boolean || null}
         */
        this.NextOver = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.LogContextInfos) {
            this.LogContextInfos = new Array();
            for (let z in params.LogContextInfos) {
                let obj = new LogContextInfo();
                obj.deserialize(params.LogContextInfos[z]);
                this.LogContextInfos.push(obj);
            }
        }
        this.PrevOver = 'PrevOver' in params ? params.PrevOver : null;
        this.NextOver = 'NextOver' in params ? params.NextOver : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CheckFunction response structure.
 * @class
 */
class CheckFunctionResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Failure error code
         * @type {number || null}
         */
        this.ErrorCode = null;

        /**
         * Failure error message
         * @type {string || null}
         */
        this.ErrorMsg = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ErrorCode = 'ErrorCode' in params ? params.ErrorCode : null;
        this.ErrorMsg = 'ErrorMsg' in params ? params.ErrorMsg : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DeleteExport request structure.
 * @class
 */
class DeleteExportRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log export ID
         * @type {string || null}
         */
        this.ExportId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ExportId = 'ExportId' in params ? params.ExportId : null;

    }
}

/**
 * PreviewKafkaRecharge request structure.
 * @class
 */
class PreviewKafkaRechargeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Preview type. Valid values: 1 (source data preview) and 2 (result preview).
         * @type {number || null}
         */
        this.PreviewType = null;

        /**
         * Kafka type. Valid values: 0 (Tencent Cloud CKafka) and 1 (customer's Kafka)
         * @type {number || null}
         */
        this.KafkaType = null;

        /**
         * List of Kafka-related topics that the user needs to import, separated by commas. Supports up to 100 topics.
         * @type {string || null}
         */
        this.UserKafkaTopics = null;

        /**
         * Position for data import. Valid values: -2 (earliest, default) and -1 (latest).
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Tencent Cloud CKafka instance ID.
KafkaInstance is required when KafkaType is 0
         * @type {string || null}
         */
        this.KafkaInstance = null;

        /**
         * Service AddressServerAddr is required when KafkaType is 1
         * @type {string || null}
         */
        this.ServerAddr = null;

        /**
         * Whether ServerAddr is a secure connection.
Valid when KafkaType is 1.
         * @type {boolean || null}
         */
        this.IsEncryptionAddr = null;

        /**
         * Encrypted Access ProtocolWhen KafkaType is 1 and IsEncryptionAddr is true, Protocol is required
         * @type {KafkaProtocolInfo || null}
         */
        this.Protocol = null;

        /**
         * Kafka consumer group name
         * @type {string || null}
         */
        this.ConsumerGroupName = null;

        /**
         * Log import rule
         * @type {LogRechargeRuleInfo || null}
         */
        this.LogRechargeRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.PreviewType = 'PreviewType' in params ? params.PreviewType : null;
        this.KafkaType = 'KafkaType' in params ? params.KafkaType : null;
        this.UserKafkaTopics = 'UserKafkaTopics' in params ? params.UserKafkaTopics : null;
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.KafkaInstance = 'KafkaInstance' in params ? params.KafkaInstance : null;
        this.ServerAddr = 'ServerAddr' in params ? params.ServerAddr : null;
        this.IsEncryptionAddr = 'IsEncryptionAddr' in params ? params.IsEncryptionAddr : null;

        if (params.Protocol) {
            let obj = new KafkaProtocolInfo();
            obj.deserialize(params.Protocol)
            this.Protocol = obj;
        }
        this.ConsumerGroupName = 'ConsumerGroupName' in params ? params.ConsumerGroupName : null;

        if (params.LogRechargeRule) {
            let obj = new LogRechargeRuleInfo();
            obj.deserialize(params.LogRechargeRule)
            this.LogRechargeRule = obj;
        }

    }
}

/**
 * SplitPartition response structure.
 * @class
 */
class SplitPartitionResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Split result set
         * @type {Array.<PartitionInfo> || null}
         */
        this.Partitions = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Partitions) {
            this.Partitions = new Array();
            for (let z in params.Partitions) {
                let obj = new PartitionInfo();
                obj.deserialize(params.Partitions[z]);
                this.Partitions.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateDataTransform response structure.
 * @class
 */
class CreateDataTransformResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Task ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Log context information
 * @class
 */
class LogContextInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log source device
         * @type {string || null}
         */
        this.Source = null;

        /**
         * Collection path
         * @type {string || null}
         */
        this.Filename = null;

        /**
         * Log content
         * @type {string || null}
         */
        this.Content = null;

        /**
         * Log package number
         * @type {string || null}
         */
        this.PkgId = null;

        /**
         * Log number in log package
         * @type {number || null}
         */
        this.PkgLogId = null;

        /**
         * Log timestamp
         * @type {number || null}
         */
        this.BTime = null;

        /**
         * Source host name of logs
Note: This field may return `null`, indicating that no valid value was found.
         * @type {string || null}
         */
        this.HostName = null;

        /**
         * Raw log (this parameter has a value only when an exception occurred while creating indexes for logs).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.RawLog = null;

        /**
         * The cause of index creation exception (this parameter has a value only when an exception occurred while creating indexes for logs).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.IndexStatus = null;

        /**
         * Highlighted description of log contentNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<HighLightItem> || null}
         */
        this.HighLights = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Source = 'Source' in params ? params.Source : null;
        this.Filename = 'Filename' in params ? params.Filename : null;
        this.Content = 'Content' in params ? params.Content : null;
        this.PkgId = 'PkgId' in params ? params.PkgId : null;
        this.PkgLogId = 'PkgLogId' in params ? params.PkgLogId : null;
        this.BTime = 'BTime' in params ? params.BTime : null;
        this.HostName = 'HostName' in params ? params.HostName : null;
        this.RawLog = 'RawLog' in params ? params.RawLog : null;
        this.IndexStatus = 'IndexStatus' in params ? params.IndexStatus : null;

        if (params.HighLights) {
            this.HighLights = new Array();
            for (let z in params.HighLights) {
                let obj = new HighLightItem();
                obj.deserialize(params.HighLights[z]);
                this.HighLights.push(obj);
            }
        }

    }
}

/**
 * ModifyShipper request structure.
 * @class
 */
class ModifyShipperRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping rule ID
         * @type {string || null}
         */
        this.ShipperId = null;

        /**
         * New destination bucket in shipping rule
         * @type {string || null}
         */
        this.Bucket = null;

        /**
         * New destination directory prefix in shipping rule
         * @type {string || null}
         */
        this.Prefix = null;

        /**
         * Shipping rule status
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Shipping rule name
         * @type {string || null}
         */
        this.ShipperName = null;

        /**
         * Shipping time interval in seconds. Default value: 300. Value range: 300 to 900
         * @type {number || null}
         */
        this.Interval = null;

        /**
         * Maximum size of a file to be shipped, in MB. Default value: 256. Value range: 5 to 256
         * @type {number || null}
         */
        this.MaxSize = null;

        /**
         * Filter rules for shipped logs. Only logs matching the rules can be shipped. All rules are in the AND relationship, and up to five rules can be added. If the array is empty, no filtering will be performed, and all logs will be shipped.
         * @type {Array.<FilterRuleInfo> || null}
         */
        this.FilterRules = null;

        /**
         * Partition rule of shipped log, which can be represented in `strftime` time format
         * @type {string || null}
         */
        this.Partition = null;

        /**
         * Compression configuration of shipped log
         * @type {CompressInfo || null}
         */
        this.Compress = null;

        /**
         * Format configuration of shipped log content
         * @type {ContentInfo || null}
         */
        this.Content = null;

        /**
         * Naming a shipping file. Valid values: `0` (by random number), `1` (by shipping time). Default value: `0`.
         * @type {number || null}
         */
        this.FilenameMode = null;

        /**
         * COS bucket type
         * @type {string || null}
         */
        this.StorageType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ShipperId = 'ShipperId' in params ? params.ShipperId : null;
        this.Bucket = 'Bucket' in params ? params.Bucket : null;
        this.Prefix = 'Prefix' in params ? params.Prefix : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.ShipperName = 'ShipperName' in params ? params.ShipperName : null;
        this.Interval = 'Interval' in params ? params.Interval : null;
        this.MaxSize = 'MaxSize' in params ? params.MaxSize : null;

        if (params.FilterRules) {
            this.FilterRules = new Array();
            for (let z in params.FilterRules) {
                let obj = new FilterRuleInfo();
                obj.deserialize(params.FilterRules[z]);
                this.FilterRules.push(obj);
            }
        }
        this.Partition = 'Partition' in params ? params.Partition : null;

        if (params.Compress) {
            let obj = new CompressInfo();
            obj.deserialize(params.Compress)
            this.Compress = obj;
        }

        if (params.Content) {
            let obj = new ContentInfo();
            obj.deserialize(params.Content)
            this.Content = obj;
        }
        this.FilenameMode = 'FilenameMode' in params ? params.FilenameMode : null;
        this.StorageType = 'StorageType' in params ? params.StorageType : null;

    }
}

/**
 * Alarm notification recipient information
 * @class
 */
class NoticeReceiver extends  AbstractModel {
    constructor(){
        super();

        /**
         * Recipient type. Valid values:
<br><li> `Uin`: user ID
<br><li> `Group`: user group ID
Currently, other recipient types are not supported.
         * @type {string || null}
         */
        this.ReceiverType = null;

        /**
         * Recipient
         * @type {Array.<number> || null}
         */
        this.ReceiverIds = null;

        /**
         * Notification method
<br><li> `Email`: email
<br><li> `Sms`: SMS
<br><li> `WeChat`: WeChat
<br><li> `Phone`: phone
         * @type {Array.<string> || null}
         */
        this.ReceiverChannels = null;

        /**
         * Start time for allowed message receipt
         * @type {string || null}
         */
        this.StartTime = null;

        /**
         * End time for allowed message receipt
         * @type {string || null}
         */
        this.EndTime = null;

        /**
         * Index
         * @type {number || null}
         */
        this.Index = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ReceiverType = 'ReceiverType' in params ? params.ReceiverType : null;
        this.ReceiverIds = 'ReceiverIds' in params ? params.ReceiverIds : null;
        this.ReceiverChannels = 'ReceiverChannels' in params ? params.ReceiverChannels : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;
        this.Index = 'Index' in params ? params.Index : null;

    }
}

/**
 * CreateKafkaRecharge request structure.
 * @class
 */
class CreateKafkaRechargeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Target topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Kafka data import configuration name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Kafka type. Valid values: 0 (Tencent Cloud CKafka) and 1 (customer's Kafka).
         * @type {number || null}
         */
        this.KafkaType = null;

        /**
         * List of Kafka topics to import data from. Separate multiple topics with commas (,).
         * @type {string || null}
         */
        this.UserKafkaTopics = null;

        /**
         * Position for data import. Valid values: -2 (earliest, default) and -1 (latest).
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Log Import Rules.
         * @type {LogRechargeRuleInfo || null}
         */
        this.LogRechargeRule = null;

        /**
         * CKafka instance ID, which is required when `KafkaType` is set to `0`
         * @type {string || null}
         */
        this.KafkaInstance = null;

        /**
         * Service address, which is required when `KafkaType` is set to `1`
         * @type {string || null}
         */
        this.ServerAddr = null;

        /**
         * Whether the service address uses an encrypted connection, which is required when `KafkaType` is set to `1`
         * @type {boolean || null}
         */
        this.IsEncryptionAddr = null;

        /**
         * Encrypted Access ProtocolWhen KafkaType is 1 and IsEncryptionAddr is true, Protocol is required
         * @type {KafkaProtocolInfo || null}
         */
        this.Protocol = null;

        /**
         * Kafka consumer group name
         * @type {string || null}
         */
        this.ConsumerGroupName = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.KafkaType = 'KafkaType' in params ? params.KafkaType : null;
        this.UserKafkaTopics = 'UserKafkaTopics' in params ? params.UserKafkaTopics : null;
        this.Offset = 'Offset' in params ? params.Offset : null;

        if (params.LogRechargeRule) {
            let obj = new LogRechargeRuleInfo();
            obj.deserialize(params.LogRechargeRule)
            this.LogRechargeRule = obj;
        }
        this.KafkaInstance = 'KafkaInstance' in params ? params.KafkaInstance : null;
        this.ServerAddr = 'ServerAddr' in params ? params.ServerAddr : null;
        this.IsEncryptionAddr = 'IsEncryptionAddr' in params ? params.IsEncryptionAddr : null;

        if (params.Protocol) {
            let obj = new KafkaProtocolInfo();
            obj.deserialize(params.Protocol)
            this.Protocol = obj;
        }
        this.ConsumerGroupName = 'ConsumerGroupName' in params ? params.ConsumerGroupName : null;

    }
}

/**
 * DeleteKafkaRecharge request structure.
 * @class
 */
class DeleteKafkaRechargeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Kafka data import configuration ID
         * @type {string || null}
         */
        this.Id = null;

        /**
         * Target CLS log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Id = 'Id' in params ? params.Id : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

    }
}

/**
 * Index rule. At least one of the `FullText`, `KeyValue`, and `Tag` parameters must be valid.
 * @class
 */
class RuleInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Full-text index configuration. If empty, full-text indexing is not enabled.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {FullTextInfo || null}
         */
        this.FullText = null;

        /**
         * Key-value index configuration. If empty, key-value indexing is not enabled.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {RuleKeyValueInfo || null}
         */
        this.KeyValue = null;

        /**
         * Metadata field index configuration. If empty, metadata field indexing is not enabled.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {RuleTagInfo || null}
         */
        this.Tag = null;

        /**
         * Key-value index automatic configuration. If empty, the feature is not enabled.Once enabled, fields within logs are automatically added to the key-value index, including fields added to logs subsequently.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {DynamicIndex || null}
         */
        this.DynamicIndex = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.FullText) {
            let obj = new FullTextInfo();
            obj.deserialize(params.FullText)
            this.FullText = obj;
        }

        if (params.KeyValue) {
            let obj = new RuleKeyValueInfo();
            obj.deserialize(params.KeyValue)
            this.KeyValue = obj;
        }

        if (params.Tag) {
            let obj = new RuleTagInfo();
            obj.deserialize(params.Tag)
            this.Tag = obj;
        }

        if (params.DynamicIndex) {
            let obj = new DynamicIndex();
            obj.deserialize(params.DynamicIndex)
            this.DynamicIndex = obj;
        }

    }
}

/**
 * CreateConfig response structure.
 * @class
 */
class CreateConfigResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection configuration ID
         * @type {string || null}
         */
        this.ConfigId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ConfigId = 'ConfigId' in params ? params.ConfigId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateConsumer request structure.
 * @class
 */
class CreateConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID to bind
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Whether to deliver log Metadata information, default is true.When NeedContent is true: Content field is valid.When NeedContent is false: Content field is invalid.
         * @type {boolean || null}
         */
        this.NeedContent = null;

        /**
         * Metadata to ship if `NeedContent` is `true`
         * @type {ConsumerContent || null}
         */
        this.Content = null;

        /**
         * CKafka information
         * @type {Ckafka || null}
         */
        this.Ckafka = null;

        /**
         * Compression method during delivery. Valid values: 0, 2, and 3. [0: NONE; 2: SNAPPY; 3: LZ4]
         * @type {number || null}
         */
        this.Compression = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.NeedContent = 'NeedContent' in params ? params.NeedContent : null;

        if (params.Content) {
            let obj = new ConsumerContent();
            obj.deserialize(params.Content)
            this.Content = obj;
        }

        if (params.Ckafka) {
            let obj = new Ckafka();
            obj.deserialize(params.Ckafka)
            this.Ckafka = obj;
        }
        this.Compression = 'Compression' in params ? params.Compression : null;

    }
}

/**
 * Log topic search information
 * @class
 */
class MultiTopicSearchInformation extends  AbstractModel {
    constructor(){
        super();

        /**
         * ID of the log topic to be searched for
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * You can pass through the `Context` value (validity: 1 hour) returned by the last API to continue to get logs, which can get up to 10,000 raw logs.
         * @type {string || null}
         */
        this.Context = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Context = 'Context' in params ? params.Context : null;

    }
}

/**
 * Alarm notification template type
 * @class
 */
class AlarmNotice extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm notification template name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Alarm template type. Optional values:<br><li> Trigger - Alarm Trigger </li><br><li> Recovery - Alarm Recovery </li><br><li> All - Alarm Trigger and Alarm Recovery </li>
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Information of the recipient in alarm notification template
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<NoticeReceiver> || null}
         */
        this.NoticeReceivers = null;

        /**
         * Callback information of alarm notification template
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<WebCallback> || null}
         */
        this.WebCallbacks = null;

        /**
         * Alarm notification template ID
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

        /**
         * Creation time
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Last update time
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UpdateTime = null;

        /**
         * Notification rules.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<NoticeRule> || null}
         */
        this.NoticeRules = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;
        this.Type = 'Type' in params ? params.Type : null;

        if (params.NoticeReceivers) {
            this.NoticeReceivers = new Array();
            for (let z in params.NoticeReceivers) {
                let obj = new NoticeReceiver();
                obj.deserialize(params.NoticeReceivers[z]);
                this.NoticeReceivers.push(obj);
            }
        }

        if (params.WebCallbacks) {
            this.WebCallbacks = new Array();
            for (let z in params.WebCallbacks) {
                let obj = new WebCallback();
                obj.deserialize(params.WebCallbacks[z]);
                this.WebCallbacks.push(obj);
            }
        }
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;

        if (params.NoticeRules) {
            this.NoticeRules = new Array();
            for (let z in params.NoticeRules) {
                let obj = new NoticeRule();
                obj.deserialize(params.NoticeRules[z]);
                this.NoticeRules.push(obj);
            }
        }

    }
}

/**
 * ModifyConfig response structure.
 * @class
 */
class ModifyConfigResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * OpenKafkaConsumer request structure.
 * @class
 */
class OpenKafkaConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log Topic ID
         * @type {string || null}
         */
        this.FromTopicId = null;

        /**
         * Compression mode. Valid values: `0` (no compression); `2` (snappy); `3` (LZ4)
         * @type {number || null}
         */
        this.Compression = null;

        /**
         * Kafka consumer data format
         * @type {KafkaConsumerContent || null}
         */
        this.ConsumerContent = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.FromTopicId = 'FromTopicId' in params ? params.FromTopicId : null;
        this.Compression = 'Compression' in params ? params.Compression : null;

        if (params.ConsumerContent) {
            let obj = new KafkaConsumerContent();
            obj.deserialize(params.ConsumerContent)
            this.ConsumerContent = obj;
        }

    }
}

/**
 * ModifyKafkaRecharge response structure.
 * @class
 */
class ModifyKafkaRechargeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyAlarmNotice response structure.
 * @class
 */
class ModifyAlarmNoticeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateDeliverCloudFunction response structure.
 * @class
 */
class CreateDeliverCloudFunctionResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Basic information of a data processing task
 * @class
 */
class DataTransformTaskInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Data processing task name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Data processing task ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Task status. Valid values: 1 (enabled) and 2 (disabled).
         * @type {number || null}
         */
        this.EnableFlag = null;

        /**
         * Task type. Valid values: 1 (DSL) and 2 (SQL).
         * @type {number || null}
         */
        this.Type = null;

        /**
         * Source log topic
         * @type {string || null}
         */
        this.SrcTopicId = null;

        /**
         * Current task status. Valid values: 1 (preparing), 2 (in progress), 3 (being stopped), and 4 (stopped).
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Task creation time
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Last modified time
         * @type {string || null}
         */
        this.UpdateTime = null;

        /**
         * Last enabled time. If you need to rebuild a cluster, modify this time.
         * @type {string || null}
         */
        this.LastEnableTime = null;

        /**
         * Log topic name
         * @type {string || null}
         */
        this.SrcTopicName = null;

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * Target topic ID and alias of the data processing task
         * @type {Array.<DataTransformResouceInfo> || null}
         */
        this.DstResources = null;

        /**
         * Logical function for data processing
         * @type {string || null}
         */
        this.EtlContent = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.EnableFlag = 'EnableFlag' in params ? params.EnableFlag : null;
        this.Type = 'Type' in params ? params.Type : null;
        this.SrcTopicId = 'SrcTopicId' in params ? params.SrcTopicId : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;
        this.LastEnableTime = 'LastEnableTime' in params ? params.LastEnableTime : null;
        this.SrcTopicName = 'SrcTopicName' in params ? params.SrcTopicName : null;
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;

        if (params.DstResources) {
            this.DstResources = new Array();
            for (let z in params.DstResources) {
                let obj = new DataTransformResouceInfo();
                obj.deserialize(params.DstResources[z]);
                this.DstResources.push(obj);
            }
        }
        this.EtlContent = 'EtlContent' in params ? params.EtlContent : null;

    }
}

/**
 * DescribeMachines response structure.
 * @class
 */
class DescribeMachinesResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Group of machine status information
         * @type {Array.<MachineInfo> || null}
         */
        this.Machines = null;

        /**
         * Whether the machine group has enabled automatic upgrade function. 0: Automatic upgrade not enabled; 1: Automatic upgrade enabled.
         * @type {number || null}
         */
        this.AutoUpdate = null;

        /**
         * Preset start time of automatic update of machine group
         * @type {string || null}
         */
        this.UpdateStartTime = null;

        /**
         * Preset end time of automatic update of machine group
         * @type {string || null}
         */
        this.UpdateEndTime = null;

        /**
         * Latest LogListener version available to the current user
         * @type {string || null}
         */
        this.LatestAgentVersion = null;

        /**
         * Whether to enable the service log
         * @type {boolean || null}
         */
        this.ServiceLogging = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Machines) {
            this.Machines = new Array();
            for (let z in params.Machines) {
                let obj = new MachineInfo();
                obj.deserialize(params.Machines[z]);
                this.Machines.push(obj);
            }
        }
        this.AutoUpdate = 'AutoUpdate' in params ? params.AutoUpdate : null;
        this.UpdateStartTime = 'UpdateStartTime' in params ? params.UpdateStartTime : null;
        this.UpdateEndTime = 'UpdateEndTime' in params ? params.UpdateEndTime : null;
        this.LatestAgentVersion = 'LatestAgentVersion' in params ? params.LatestAgentVersion : null;
        this.ServiceLogging = 'ServiceLogging' in params ? params.ServiceLogging : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyCosRecharge response structure.
 * @class
 */
class ModifyCosRechargeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Preview data details
 * @class
 */
class PreviewLogStatistic extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log content
         * @type {string || null}
         */
        this.LogContent = null;

        /**
         * Line number
         * @type {number || null}
         */
        this.LineNum = null;

        /**
         * Target log topic
         * @type {string || null}
         */
        this.DstTopicId = null;

        /**
         * Error code. An empty string "" indicates no error.
         * @type {string || null}
         */
        this.FailReason = null;

        /**
         * Log timestamp
         * @type {string || null}
         */
        this.Time = null;

        /**
         * Target topic name
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.DstTopicName = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogContent = 'LogContent' in params ? params.LogContent : null;
        this.LineNum = 'LineNum' in params ? params.LineNum : null;
        this.DstTopicId = 'DstTopicId' in params ? params.DstTopicId : null;
        this.FailReason = 'FailReason' in params ? params.FailReason : null;
        this.Time = 'Time' in params ? params.Time : null;
        this.DstTopicName = 'DstTopicName' in params ? params.DstTopicName : null;

    }
}

/**
 * Compression configuration of shipped log
 * @class
 */
class CompressInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Compression format. Valid values: `gzip`; `lzop`; `snappy`; `none` (no compression)
         * @type {string || null}
         */
        this.Format = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Format = 'Format' in params ? params.Format : null;

    }
}

/**
 * ApplyConfigToMachineGroup response structure.
 * @class
 */
class ApplyConfigToMachineGroupResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Details about an alarm notification group
 * @class
 */
class AlertHistoryNotice extends  AbstractModel {
    constructor(){
        super();

        /**
         * Notification group name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Notification group ID
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;

    }
}

/**
 * DeleteAlarm request structure.
 * @class
 */
class DeleteAlarmRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Alarm policy ID.
         * @type {string || null}
         */
        this.AlarmId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmId = 'AlarmId' in params ? params.AlarmId : null;

    }
}

/**
 * Alarm suppression task configuration
 * @class
 */
class AlarmShieldInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Notification Channel Group ID
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

        /**
         * Shield Rule ID
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Block start time (second-level timestamp).
         * @type {number || null}
         */
        this.StartTime = null;

        /**
         * Block end time (second-level timestamp).
         * @type {number || null}
         */
        this.EndTime = null;

        /**
         * Block type. 1: Block all notifications, 2: Block matching rules notifications according to the Rule parameter.
         * @type {number || null}
         */
        this.Type = null;

        /**
         * Rule for shielding, mandatory when Type is 2. See Product Documentation (https://intl.cloud.tencent.com/document/product/614/103178?from_cn_redirect=1#rule) for rule writing details.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Rule = null;

        /**
         * Blocking reason.
         * @type {string || null}
         */
        this.Reason = null;

        /**
         * Rule Creation Source.
1. Console; 2. API; 3. Alarm notification
         * @type {number || null}
         */
        this.Source = null;

        /**
         * Operator.
         * @type {string || null}
         */
        this.Operator = null;

        /**
         * Rule Status.
0: Not yet effective; 1: In effect; 2: Expired
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Rule Creation Time.
         * @type {number || null}
         */
        this.CreateTime = null;

        /**
         * Rule Update Time.
         * @type {number || null}
         */
        this.UpdateTime = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;
        this.Type = 'Type' in params ? params.Type : null;
        this.Rule = 'Rule' in params ? params.Rule : null;
        this.Reason = 'Reason' in params ? params.Reason : null;
        this.Source = 'Source' in params ? params.Source : null;
        this.Operator = 'Operator' in params ? params.Operator : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;

    }
}

/**
 * ModifyKafkaConsumer response structure.
 * @class
 */
class ModifyKafkaConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Machine group type description
 * @class
 */
class MachineGroupTypeInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group type. Valid values: `ip`: the IP addresses of collection machines are stored in `Values` of the machine group; `label`: the tags of the machines are stored in `Values` of the machine group
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Machine description list
         * @type {Array.<string> || null}
         */
        this.Values = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Type = 'Type' in params ? params.Type : null;
        this.Values = 'Values' in params ? params.Values : null;

    }
}

/**
 * DeleteConfigFromMachineGroup request structure.
 * @class
 */
class DeleteConfigFromMachineGroupRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

        /**
         * Collection configuration ID
         * @type {string || null}
         */
        this.ConfigId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;
        this.ConfigId = 'ConfigId' in params ? params.ConfigId : null;

    }
}

/**
 * SearchCosRechargeInfo response structure.
 * @class
 */
class SearchCosRechargeInfoResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The first few lines of a file under a matched bucketNote: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.Data = null;

        /**
         * Number of files under the matched bucket
         * @type {number || null}
         */
        this.Sum = null;

        /**
         * Current preview file path
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Path = null;

        /**
         * Reason for preview data retrieval failureNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Msg = null;

        /**
         * Status
         * @type {number || null}
         */
        this.Status = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Data = 'Data' in params ? params.Data : null;
        this.Sum = 'Sum' in params ? params.Sum : null;
        this.Path = 'Path' in params ? params.Path : null;
        this.Msg = 'Msg' in params ? params.Msg : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Shipping rule
 * @class
 */
class ShipperInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping rule ID
         * @type {string || null}
         */
        this.ShipperId = null;

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Bucket address shipped to
         * @type {string || null}
         */
        this.Bucket = null;

        /**
         * Shipping prefix directory
         * @type {string || null}
         */
        this.Prefix = null;

        /**
         * Shipping rule name
         * @type {string || null}
         */
        this.ShipperName = null;

        /**
         * Shipping time interval in seconds
         * @type {number || null}
         */
        this.Interval = null;

        /**
         * Maximum size of shipped file in MB
         * @type {number || null}
         */
        this.MaxSize = null;

        /**
         * Whether it takes effect
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Filter rule for shipped log
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<FilterRuleInfo> || null}
         */
        this.FilterRules = null;

        /**
         * Partition rule of shipped log, which can be represented in `strftime` time format
         * @type {string || null}
         */
        this.Partition = null;

        /**
         * Compression configuration of shipped log
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {CompressInfo || null}
         */
        this.Compress = null;

        /**
         * Format configuration of shipped log content
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {ContentInfo || null}
         */
        this.Content = null;

        /**
         * Creation time of shipped log
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Shipping file naming configuration. Valid values: `0` (by random number); `1` (by shipping time). Default value: `0`.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.FilenameMode = null;

        /**
         * Start time for data shipping
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.StartTime = null;

        /**
         * End time for data shipping
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.EndTime = null;

        /**
         * Progress of historical data shipping (valid only when the selected data scope contains historical data)
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Progress = null;

        /**
         * Remaining time required for shipping all historical data (valid only when the selected data scope contains historical data)
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.RemainTime = null;

        /**
         * Status of historical data shipping. Valid values:
0: Real-time data is being shipped.
1: The system is preparing for historical data shipping.
2: Historical data is being shipped.
3: An error occurred while shipping historical data.
4: Historical data shipping ended.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.HistoryStatus = null;

        /**
         * COS bucket type
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.StorageType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ShipperId = 'ShipperId' in params ? params.ShipperId : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Bucket = 'Bucket' in params ? params.Bucket : null;
        this.Prefix = 'Prefix' in params ? params.Prefix : null;
        this.ShipperName = 'ShipperName' in params ? params.ShipperName : null;
        this.Interval = 'Interval' in params ? params.Interval : null;
        this.MaxSize = 'MaxSize' in params ? params.MaxSize : null;
        this.Status = 'Status' in params ? params.Status : null;

        if (params.FilterRules) {
            this.FilterRules = new Array();
            for (let z in params.FilterRules) {
                let obj = new FilterRuleInfo();
                obj.deserialize(params.FilterRules[z]);
                this.FilterRules.push(obj);
            }
        }
        this.Partition = 'Partition' in params ? params.Partition : null;

        if (params.Compress) {
            let obj = new CompressInfo();
            obj.deserialize(params.Compress)
            this.Compress = obj;
        }

        if (params.Content) {
            let obj = new ContentInfo();
            obj.deserialize(params.Content)
            this.Content = obj;
        }
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.FilenameMode = 'FilenameMode' in params ? params.FilenameMode : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;
        this.Progress = 'Progress' in params ? params.Progress : null;
        this.RemainTime = 'RemainTime' in params ? params.RemainTime : null;
        this.HistoryStatus = 'HistoryStatus' in params ? params.HistoryStatus : null;
        this.StorageType = 'StorageType' in params ? params.StorageType : null;

    }
}

/**
 * CreateCosRecharge response structure.
 * @class
 */
class CreateCosRechargeResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * cos_recharge record ID
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Id = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Id = 'Id' in params ? params.Id : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeAlertRecordHistory response structure.
 * @class
 */
class DescribeAlertRecordHistoryResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Total alarm records
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * Alarm record details
         * @type {Array.<AlertHistoryRecord> || null}
         */
        this.Records = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;

        if (params.Records) {
            this.Records = new Array();
            for (let z in params.Records) {
                let obj = new AlertHistoryRecord();
                obj.deserialize(params.Records[z]);
                this.Records.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Field information of key value or metafield index
 * @class
 */
class KeyValueInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Name of the field for which you want to configure a key-value or metadata field index. The name can contain letters, digits, underscores, and symbols -./@ and cannot start with an underscore.

Note:
For a metadata field, set its `Key` to be consistent with the one for log uploading, without prefixing it with `__TAG__.`. `__TAG__.` will be prefixed automatically for display in the console.
2. The total number of keys in key-value indexes (`KeyValue`) and metadata field indexes (`Tag`) cannot exceed 300.
3. The number of levels in `Key` cannot exceed 10. Example: a.b.c.d.e.f.g.h.j.k
4. JSON parent and child fields (such as “a” and “a.b”) cannot be contained at the same time.
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Field index description information
         * @type {ValueInfo || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;

        if (params.Value) {
            let obj = new ValueInfo();
            obj.deserialize(params.Value)
            this.Value = obj;
        }

    }
}

/**
 * AddMachineGroupInfo response structure.
 * @class
 */
class AddMachineGroupInfoResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyMachineGroup request structure.
 * @class
 */
class ModifyMachineGroupRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

        /**
         * Machine group name
         * @type {string || null}
         */
        this.GroupName = null;

        /**
         * Machine group type
         * @type {MachineGroupTypeInfo || null}
         */
        this.MachineGroupType = null;

        /**
         * Tag list
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Whether to enable automatic update for the machine group
         * @type {boolean || null}
         */
        this.AutoUpdate = null;

        /**
         * Update start time. We recommend you update LogListener during off-peak hours.
         * @type {string || null}
         */
        this.UpdateStartTime = null;

        /**
         * Update end time. We recommend you update LogListener during off-peak hours.
         * @type {string || null}
         */
        this.UpdateEndTime = null;

        /**
         * Whether to enable the service log to record the logs generated by the LogListener service itself. After it is enabled, the internal logset `cls_service_logging` and the `loglistener_status`, `loglistener_alarm`, and `loglistener_business` log topics will be created, which will not incur fees.
         * @type {boolean || null}
         */
        this.ServiceLogging = null;

        /**
         * Regular offline cleaning time for machines in machine group
         * @type {number || null}
         */
        this.DelayCleanupTime = null;

        /**
         * Metadata information list of a machine group
         * @type {Array.<MetaTagInfo> || null}
         */
        this.MetaTags = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;
        this.GroupName = 'GroupName' in params ? params.GroupName : null;

        if (params.MachineGroupType) {
            let obj = new MachineGroupTypeInfo();
            obj.deserialize(params.MachineGroupType)
            this.MachineGroupType = obj;
        }

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.AutoUpdate = 'AutoUpdate' in params ? params.AutoUpdate : null;
        this.UpdateStartTime = 'UpdateStartTime' in params ? params.UpdateStartTime : null;
        this.UpdateEndTime = 'UpdateEndTime' in params ? params.UpdateEndTime : null;
        this.ServiceLogging = 'ServiceLogging' in params ? params.ServiceLogging : null;
        this.DelayCleanupTime = 'DelayCleanupTime' in params ? params.DelayCleanupTime : null;

        if (params.MetaTags) {
            this.MetaTags = new Array();
            for (let z in params.MetaTags) {
                let obj = new MetaTagInfo();
                obj.deserialize(params.MetaTags[z]);
                this.MetaTags.push(obj);
            }
        }

    }
}

/**
 * DescribeAlarmNotices request structure.
 * @class
 */
class DescribeAlarmNoticesRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * <li> name
Filter by Notification Channel Group Name.Type: String
Required: No</li>
<li> alarmNoticeId
Filter by Notification Channel Group ID.Type: String
Required: No</li>
<li> uid
Filter by Receiving User ID.Type: String
Required: No</li>
<li> groupId
Filter by Receiving User Group ID.Type: String
Required: No</li>

<li> deliverFlag
Filter by Delivery Status.Type: String
Required: No
Optional Values: "1": Not Enabled, "2": Enabled, "3": Delivery Exception</li>The maximum number of Filters per request is 10, and the maximum for Filter.Values is 5.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100.
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * DescribeConsumer response structure.
 * @class
 */
class DescribeConsumerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Whether the shipping task is effective
         * @type {boolean || null}
         */
        this.Effective = null;

        /**
         * Whether log metadata is shipped
         * @type {boolean || null}
         */
        this.NeedContent = null;

        /**
         * Metadata shipped if `NeedContent` is `true`
Note: This field may return `null`, indicating that no valid value was found.
         * @type {ConsumerContent || null}
         */
        this.Content = null;

        /**
         * CKafka information
         * @type {Ckafka || null}
         */
        this.Ckafka = null;

        /**
         * Compression mode. Valid values: `0` (no compression), `2` (snappy), `3` (LZ4).
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Compression = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Effective = 'Effective' in params ? params.Effective : null;
        this.NeedContent = 'NeedContent' in params ? params.NeedContent : null;

        if (params.Content) {
            let obj = new ConsumerContent();
            obj.deserialize(params.Content)
            this.Content = obj;
        }

        if (params.Ckafka) {
            let obj = new Ckafka();
            obj.deserialize(params.Ckafka)
            this.Ckafka = obj;
        }
        this.Compression = 'Compression' in params ? params.Compression : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Filters
 * @class
 */
class MetricLabel extends  AbstractModel {
    constructor(){
        super();

        /**
         * Metric NameNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Metric content Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * ModifyTopic request structure.
 * @class
 */
class ModifyTopicRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Log topic name
         * @type {string || null}
         */
        this.TopicName = null;

        /**
         * Tag description list. This parameter is used to bind a tag to a log topic. Up to 10 tag key-value pairs are supported, and they must be unique.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Whether the topic has log collection enabled. true: collection enabled; false: collection disabled.The console currently does not support modifying this parameter.
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Whether to enable automatic split
         * @type {boolean || null}
         */
        this.AutoSplit = null;

        /**
         * Maximum number of partitions to split into for this topic if automatic split is enabled
         * @type {number || null}
         */
        this.MaxSplitPartitions = null;

        /**
         * Lifecycle in days. Value range: 1 to 3600 (STANDARD storage); 7 to 3600 (IA storage). 3640 indicates permanent retention.
         * @type {number || null}
         */
        this.Period = null;

        /**
         * Log topic description
         * @type {string || null}
         */
        this.Describes = null;

        /**
         * `0`: Disable log transitioning.
A value other than `0`: The number of STANDARD storage days after log transitioning is enabled (valid only if `StorageType` is `hot`). Note: `HotPeriod` should be greater than or equal to `7` and less than `Period`.
         * @type {number || null}
         */
        this.HotPeriod = null;

        /**
         * Free authentication switch. false: disabled; true: enabled.Once enabled, it will support specified operations for anonymous access to this log topic. For details, please see [log Topic](https://intl.cloud.tencent.com/document/product/614/41035?from_cn_redirect=1).
         * @type {boolean || null}
         */
        this.IsWebTracking = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.TopicName = 'TopicName' in params ? params.TopicName : null;

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.Status = 'Status' in params ? params.Status : null;
        this.AutoSplit = 'AutoSplit' in params ? params.AutoSplit : null;
        this.MaxSplitPartitions = 'MaxSplitPartitions' in params ? params.MaxSplitPartitions : null;
        this.Period = 'Period' in params ? params.Period : null;
        this.Describes = 'Describes' in params ? params.Describes : null;
        this.HotPeriod = 'HotPeriod' in params ? params.HotPeriod : null;
        this.IsWebTracking = 'IsWebTracking' in params ? params.IsWebTracking : null;

    }
}

/**
 * Information of the CKafka instance to ship to
 * @class
 */
class Ckafka extends  AbstractModel {
    constructor(){
        super();

        /**
         * CKafka VIP
         * @type {string || null}
         */
        this.Vip = null;

        /**
         * CKafka Vport
         * @type {string || null}
         */
        this.Vport = null;

        /**
         * CKafka instance ID
         * @type {string || null}
         */
        this.InstanceId = null;

        /**
         * CKafka instance name
         * @type {string || null}
         */
        this.InstanceName = null;

        /**
         * CKafka topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * CKafka topic name
         * @type {string || null}
         */
        this.TopicName = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Vip = 'Vip' in params ? params.Vip : null;
        this.Vport = 'Vport' in params ? params.Vport : null;
        this.InstanceId = 'InstanceId' in params ? params.InstanceId : null;
        this.InstanceName = 'InstanceName' in params ? params.InstanceName : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.TopicName = 'TopicName' in params ? params.TopicName : null;

    }
}

/**
 * DescribeMachines request structure.
 * @class
 */
class DescribeMachinesRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * ID of the machine group to be queried
         * @type {string || null}
         */
        this.GroupId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;

    }
}

/**
 * Multiple trigger conditions.
 * @class
 */
class MultiCondition extends  AbstractModel {
    constructor(){
        super();

        /**
         * Trigger condition.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Condition = null;

        /**
         * Alarm severity. 0: Warning (Warn); 1: Reminder (Info); 2: Urgent (Critical).<li> If not specified, the default is 0.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.AlarmLevel = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Condition = 'Condition' in params ? params.Condition : null;
        this.AlarmLevel = 'AlarmLevel' in params ? params.AlarmLevel : null;

    }
}

/**
 * DeleteAlarmNotice request structure.
 * @class
 */
class DeleteAlarmNoticeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Notification group ID
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;

    }
}

/**
 * DescribeScheduledSqlInfo request structure.
 * @class
 */
class DescribeScheduledSqlInfoRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100.
         * @type {number || null}
         */
        this.Limit = null;

        /**
         * Task name.
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Task ID.
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * <li>srcTopicName: Filter by Source Log Topic Name, fuzzy match. Type: String. Required: No</li><li>dstTopicName: Filter by Destination Log Topic Name, fuzzy match. Type: String. Required: No</li><li>srcTopicId: Filter by Source Log Topic ID. Type: String. Required: No</li><li>dstTopicId: Filter by Destination Log Topic ID. Type: String. Required: No</li><li>bizType: Filter by Topic Type, 0: log topic; 1: metric topic. Type: String. Required: No</li><li>status: Filter by Task Status, 1: running; 2: stopped. Type: String. Required: No</li><li>taskName: Filter by Task Name, fuzzy match. Type: String. Required: No</li><li>taskId: Filter by Task ID, fuzzy match. Type: String. Required: No</li>
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.TaskId = 'TaskId' in params ? params.TaskId : null;

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }

    }
}

/**
 * DeleteLogset request structure.
 * @class
 */
class DeleteLogsetRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Logset ID
         * @type {string || null}
         */
        this.LogsetId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;

    }
}

/**
 * Machine status information
 * @class
 */
class MachineInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine IP
         * @type {string || null}
         */
        this.Ip = null;

        /**
         * Machine instance IDNote: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.InstanceID = null;

        /**
         * Machine status. Valid values: `0`: exceptional; `1`: normal
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Machine disconnection time. If the value is empty, the machine is normal. If the machine is exceptional, a specific value will be returned.
         * @type {string || null}
         */
        this.OfflineTime = null;

        /**
         * Whether to enable automatic update for the machine. Valid values: `0`: no; `1`: yes
         * @type {number || null}
         */
        this.AutoUpdate = null;

        /**
         * Current machine version number
         * @type {string || null}
         */
        this.Version = null;

        /**
         * Machine upgrade status. 0: Upgrade successful; 1: Upgrading; -1: Upgrade failed.
         * @type {number || null}
         */
        this.UpdateStatus = null;

        /**
         * Machine upgrade result identifier.0: Success; 1200: Upgrade successful; Other values indicate exceptions.
         * @type {number || null}
         */
        this.ErrCode = null;

        /**
         * Machine upgrade result information."ok": Success; "update success": Upgrade successful; Other values indicate the reason for failure.
         * @type {string || null}
         */
        this.ErrMsg = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Ip = 'Ip' in params ? params.Ip : null;
        this.InstanceID = 'InstanceID' in params ? params.InstanceID : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.OfflineTime = 'OfflineTime' in params ? params.OfflineTime : null;
        this.AutoUpdate = 'AutoUpdate' in params ? params.AutoUpdate : null;
        this.Version = 'Version' in params ? params.Version : null;
        this.UpdateStatus = 'UpdateStatus' in params ? params.UpdateStatus : null;
        this.ErrCode = 'ErrCode' in params ? params.ErrCode : null;
        this.ErrMsg = 'ErrMsg' in params ? params.ErrMsg : null;

    }
}

/**
 * ModifyLogset response structure.
 * @class
 */
class ModifyLogsetResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Monitoring task execution time point in alarm policy
 * @class
 */
class MonitorTime extends  AbstractModel {
    constructor(){
        super();

        /**
         * Valid values:
<br><li> `Period`: periodic execution
<br><li> `Fixed`: scheduled execution
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Execution interval or scheduled time point in minutes. Value range: 1–1440.
         * @type {number || null}
         */
        this.Time = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Type = 'Type' in params ? params.Type : null;
        this.Time = 'Time' in params ? params.Time : null;

    }
}

/**
 * SearchLog request structure.
 * @class
 */
class SearchLogRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Start time of the log to be searched, which is a Unix timestamp in milliseconds
         * @type {number || null}
         */
        this.From = null;

        /**
         * End time of the log to be searched, which is a Unix timestamp in milliseconds
         * @type {number || null}
         */
        this.To = null;

        /**
         * Search and analysis statement. Maximum length: 12 KB
A statement is in the format of <a href="https://intl.cloud.tencent.com/document/product/614/47044?from_cn_redirect=1" target="_blank">[search criteria]</a> | <a href="https://intl.cloud.tencent.com/document/product/614/44061?from_cn_redirect=1" target="_blank">[SQL statement]</a>. You can omit the pipe symbol <code> | </code> and SQL statement when log analysis is not required.
Queries all logs using * or an empty string
         * @type {string || null}
         */
        this.Query = null;

        /**
         * Retrieval syntax rule, default is 0, recommended to use 1 (CQL syntax).0: Lucene syntax, 1: CQL syntax.
For detailed explanation, refer to <a href="https://intl.cloud.tencent.com/document/product/614/47044?from_cn_redirect=1#RetrievesConditionalRules" target="_blank">Retrieve Syntax Rules</a>
         * @type {number || null}
         */
        this.SyntaxRule = null;

        /**
         * - The ID of the log topic to be searched for. Only one log topic can be specified.
- To search for multiple log topics at a time, use the `Topics` parameter.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * - The IDs of the log topics (up to 20) to be searched for.
- To search for a single log topic, use the `TopicId` parameter.
- You cannot use both `TopicId` and `Topics`.
         * @type {Array.<MultiTopicSearchInformation> || null}
         */
        this.Topics = null;

        /**
         * Specifies the number of raw logs returned in a single query, default is 100, maximum is 1000. To obtain subsequent logs, use the Context parameter.Note:* This is only valid when the search and analysis statement (Query) does not contain SQL* Method for specifying SQL result count refers to <a href="https://intl.cloud.tencent.com/document/product/614/58977?from_cn_redirect=1" target="_blank">SQL LIMIT Syntax</a>
         * @type {number || null}
         */
        this.Limit = null;

        /**
         * Time order of the logs returned. Valid values: `asc` (ascending); `desc`: (descending). Default value: `desc`
Notes:
* This parameter is valid only when the query statement (`Query`) does not contain an SQL statement.
* To sort the analysis results, see <a href="https://intl.cloud.tencent.com/document/product/614/58978?from_cn_redirect=1" target="_blank">SQL ORDER BY Syntax</a>.
         * @type {string || null}
         */
        this.Sort = null;

        /**
         * Pass the Context value returned by the last API call to retrieve more subsequent logs. A total of up to 10,000 raw logs can be obtained, with an expiration time of 1 hour.Note:* When passing this parameter, do not modify any other parameters except for this one* Only applicable for single log topic retrieval. When retrieving multiple log topics, use the Context in Topics.* This is only valid when the retrieval analysis statement (Query) does not contain SQL. For obtaining subsequent SQL results, refer to <a href="https://intl.cloud.tencent.com/document/product/614/58977?from_cn_redirect=1" target="_blank">SQL LIMIT Syntax</a>
         * @type {string || null}
         */
        this.Context = null;

        /**
         * Indicates whether to sample raw logs before statistical analysis (`Query` includes SQL statements).
`0`: Auto-sample.
`0-1`: Sample by the specified sample rate, such as `0.02`.
`1`: Precise analysis without sampling.
Default value: `1`
         * @type {number || null}
         */
        this.SamplingRate = null;

        /**
         * If the value is `true`, the new response method will be used, and the output parameters `AnalysisRecords` and `Columns` will be valid.
If the value is `false`, the old response method will be used, and the output parameters `AnalysisResults` and `ColNames` will be valid.
The two response methods differ slightly in terms of encoding format. You are advised to use the new method (`true`).
         * @type {boolean || null}
         */
        this.UseNewAnalysis = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.From = 'From' in params ? params.From : null;
        this.To = 'To' in params ? params.To : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;

        if (params.Topics) {
            this.Topics = new Array();
            for (let z in params.Topics) {
                let obj = new MultiTopicSearchInformation();
                obj.deserialize(params.Topics[z]);
                this.Topics.push(obj);
            }
        }
        this.Limit = 'Limit' in params ? params.Limit : null;
        this.Sort = 'Sort' in params ? params.Sort : null;
        this.Context = 'Context' in params ? params.Context : null;
        this.SamplingRate = 'SamplingRate' in params ? params.SamplingRate : null;
        this.UseNewAnalysis = 'UseNewAnalysis' in params ? params.UseNewAnalysis : null;

    }
}

/**
 * CreateMachineGroup request structure.
 * @class
 */
class CreateMachineGroupRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group name, which must be unique
         * @type {string || null}
         */
        this.GroupName = null;

        /**
         * Type of the machine group to be created. Valid values: `ip`: use the IP string list in `Values` to create a machine group; `label`: use the tag string list in `Values` to create a machine group
         * @type {MachineGroupTypeInfo || null}
         */
        this.MachineGroupType = null;

        /**
         * Tag description list. This parameter is used to bind a tag to a machine group. Up to 10 tag key-value pairs are supported, and a resource can be bound to only one tag key.
         * @type {Array.<Tag> || null}
         */
        this.Tags = null;

        /**
         * Whether to enable automatic update for the machine group
         * @type {boolean || null}
         */
        this.AutoUpdate = null;

        /**
         * Update start time. We recommend you update LogListener during off-peak hours.
         * @type {string || null}
         */
        this.UpdateStartTime = null;

        /**
         * Update end time. We recommend you update LogListener during off-peak hours.
         * @type {string || null}
         */
        this.UpdateEndTime = null;

        /**
         * Whether to enable the service log to record the logs generated by the LogListener service itself. After it is enabled, the internal logset `cls_service_logging` and the `loglistener_status`, `loglistener_alarm`, and `loglistener_business` log topics will be created, which will not incur fees
         * @type {boolean || null}
         */
        this.ServiceLogging = null;

        /**
         * Offline cleaning time for machines in machine group
         * @type {number || null}
         */
        this.DelayCleanupTime = null;

        /**
         * Metadata information list of a machine group
         * @type {Array.<MetaTagInfo> || null}
         */
        this.MetaTags = null;

        /**
         * System type, default 0, 0: Linux, 1: Windows
         * @type {number || null}
         */
        this.OSType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupName = 'GroupName' in params ? params.GroupName : null;

        if (params.MachineGroupType) {
            let obj = new MachineGroupTypeInfo();
            obj.deserialize(params.MachineGroupType)
            this.MachineGroupType = obj;
        }

        if (params.Tags) {
            this.Tags = new Array();
            for (let z in params.Tags) {
                let obj = new Tag();
                obj.deserialize(params.Tags[z]);
                this.Tags.push(obj);
            }
        }
        this.AutoUpdate = 'AutoUpdate' in params ? params.AutoUpdate : null;
        this.UpdateStartTime = 'UpdateStartTime' in params ? params.UpdateStartTime : null;
        this.UpdateEndTime = 'UpdateEndTime' in params ? params.UpdateEndTime : null;
        this.ServiceLogging = 'ServiceLogging' in params ? params.ServiceLogging : null;
        this.DelayCleanupTime = 'DelayCleanupTime' in params ? params.DelayCleanupTime : null;

        if (params.MetaTags) {
            this.MetaTags = new Array();
            for (let z in params.MetaTags) {
                let obj = new MetaTagInfo();
                obj.deserialize(params.MetaTags[z]);
                this.MetaTags.push(obj);
            }
        }
        this.OSType = 'OSType' in params ? params.OSType : null;

    }
}

/**
 * Description of the tag pair bound to a resource instance when it is created
 * @class
 */
class Tag extends  AbstractModel {
    constructor(){
        super();

        /**
         * The tag key.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Key = null;

        /**
         * The tag value.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Value = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Value = 'Value' in params ? params.Value : null;

    }
}

/**
 * ModifyAlarmShield request structure.
 * @class
 */
class ModifyAlarmShieldRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Blocking rule ID.
         * @type {string || null}
         */
        this.TaskId = null;

        /**
         * Notification channel group ID.
         * @type {string || null}
         */
        this.AlarmNoticeId = null;

        /**
         * Block start time (second-level timestamp).
         * @type {number || null}
         */
        this.StartTime = null;

        /**
         * Block end time (second-level timestamp).
         * @type {number || null}
         */
        this.EndTime = null;

        /**
         * Block type. 1: Block all notifications, 2: Block matching rules notifications according to the Rule parameter.
         * @type {number || null}
         */
        this.Type = null;

        /**
         * Blocking rules, required when Type is 2. For detailed information on filling in rules, see [Product Documentation](https://intl.cloud.tencent.com/document/product/614/103178?from_cn_redirect=1#rule).
         * @type {string || null}
         */
        this.Rule = null;

        /**
         * Blocking Reason
         * @type {string || null}
         */
        this.Reason = null;

        /**
         * Rule status. Only when the rule status is in effect (status:1) can it be modified to expired (status:2).
         * @type {number || null}
         */
        this.Status = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TaskId = 'TaskId' in params ? params.TaskId : null;
        this.AlarmNoticeId = 'AlarmNoticeId' in params ? params.AlarmNoticeId : null;
        this.StartTime = 'StartTime' in params ? params.StartTime : null;
        this.EndTime = 'EndTime' in params ? params.EndTime : null;
        this.Type = 'Type' in params ? params.Type : null;
        this.Rule = 'Rule' in params ? params.Rule : null;
        this.Reason = 'Reason' in params ? params.Reason : null;
        this.Status = 'Status' in params ? params.Status : null;

    }
}

/**
 * DescribeExports response structure.
 * @class
 */
class DescribeExportsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * List of exported logs
         * @type {Array.<ExportInfo> || null}
         */
        this.Exports = null;

        /**
         * Total number
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Exports) {
            this.Exports = new Array();
            for (let z in params.Exports) {
                let obj = new ExportInfo();
                obj.deserialize(params.Exports[z]);
                this.Exports.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ApplyConfigToMachineGroup request structure.
 * @class
 */
class ApplyConfigToMachineGroupRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection configuration ID
         * @type {string || null}
         */
        this.ConfigId = null;

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ConfigId = 'ConfigId' in params ? params.ConfigId : null;
        this.GroupId = 'GroupId' in params ? params.GroupId : null;

    }
}

/**
 * GetAlarmLog request structure.
 * @class
 */
class GetAlarmLogRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Start time of the execution detail to be queried, Unix timestamp, unit: ms.
         * @type {number || null}
         */
        this.From = null;

        /**
         * End time of the execution detail to be queried, Unix timestamp, unit: ms.
         * @type {number || null}
         */
        this.To = null;

        /**
         * Query filter criteria, for example:
- Query by alert policy ID: `alert_id:"alarm-0745ec00-e605-xxxx-b50b-54afe61fc971"`
- Query by monitoring object ID: `monitored_object:"823d8bfa-76a7-xxxx-8399-8cda74d4009b" `
- Query by alarm policy ID and monitoring object ID: `alert_id:"alarm-0745ec00-e605-xxxx-b50b-54afe61fc971" AND monitored_object:"823d8bfa-76a7-xxxx-8399-8cda74d4009b"`
- Query by alarm policy ID and monitoring object ID, supports SQL statement: `(alert_id:"alarm-5ce45495-09e8-4d58-xxxx-768134bf330c") AND (monitored_object:"3c514e84-6f1f-46ec-xxxx-05de6163f7fe") AND NOT condition_evaluate_result: "Skip" AND condition_evaluate_result:[* TO *] | SELECT count(*) as top50StatisticsTotalCount, count_if(condition_evaluate_result='ProcessError') as top50StatisticsFailureCount, count_if(notification_send_result!='NotSend') as top50NoticeTotalCount, count_if(notification_send_result='SendPartFail' or notification_send_result='SendFail') as top50NoticeFailureCount, alert_id, alert_name, monitored_object, topic_type, happen_threshold, alert_threshold, notify_template group by alert_id, alert_name, monitored_object, topic_type, happen_threshold, alert_threshold, notify_template order by top50StatisticsTotalCount desc limit 1`
         * @type {string || null}
         */
        this.Query = null;

        /**
         * The maximum number of execution details returned in a single query is 1000.
         * @type {number || null}
         */
        this.Limit = null;

        /**
         * Pass the Context value returned by the last API call to retrieve more subsequent logs. A total of up to 10,000 raw logs can be obtained, with an expiration time of 1 hour.Note:* When passing this parameter, do not modify any other parameters except for this one* This is only valid when the retrieval analysis statement (Query) does not contain SQL. For obtaining subsequent SQL results, refer to <a href="https://intl.cloud.tencent.com/document/product/614/58977?from_cn_redirect=1" target="_blank">SQL LIMIT Syntax</a>
         * @type {string || null}
         */
        this.Context = null;

        /**
         * Whether the original logs are returned in time order. Optional values are: asc (ascending) or desc (descending). The default is descNote:* This is only valid when the search and analysis statement (Query) does not contain SQL* For SQL result sorting, refer to <a href="https://intl.cloud.tencent.com/document/product/614/58978?from_cn_redirect=1" target="_blank">SQL ORDER BY Syntax</a>
         * @type {string || null}
         */
        this.Sort = null;

        /**
         * true: Indicates the use of the new retrieval result return method, with valid output parameters AnalysisRecords and Columns.false: Indicates the use of the old retrieval result return method, with valid output parameters AnalysisResults and ColNames.There is a slight difference in encoding format between the two return methods, and it is recommended to use true.
         * @type {boolean || null}
         */
        this.UseNewAnalysis = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.From = 'From' in params ? params.From : null;
        this.To = 'To' in params ? params.To : null;
        this.Query = 'Query' in params ? params.Query : null;
        this.Limit = 'Limit' in params ? params.Limit : null;
        this.Context = 'Context' in params ? params.Context : null;
        this.Sort = 'Sort' in params ? params.Sort : null;
        this.UseNewAnalysis = 'UseNewAnalysis' in params ? params.UseNewAnalysis : null;

    }
}

/**
 * DescribeMachineGroupConfigs response structure.
 * @class
 */
class DescribeMachineGroupConfigsResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Collection rule configuration list
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<ConfigInfo> || null}
         */
        this.Configs = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Configs) {
            this.Configs = new Array();
            for (let z in params.Configs) {
                let obj = new ConfigInfo();
                obj.deserialize(params.Configs[z]);
                this.Configs.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CSV content description
 * @class
 */
class CsvInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Whether to print `key` on the first row of the CSV file
         * @type {boolean || null}
         */
        this.PrintKey = null;

        /**
         * Names of keys
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.Keys = null;

        /**
         * Field delimiter
         * @type {string || null}
         */
        this.Delimiter = null;

        /**
         * Escape character used to enclose any field delimiter in field content. You can enter only a single quotation mark, double quotation mark, or an empty string.
         * @type {string || null}
         */
        this.EscapeChar = null;

        /**
         * Content used to populate non-existing fields
         * @type {string || null}
         */
        this.NonExistingField = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.PrintKey = 'PrintKey' in params ? params.PrintKey : null;
        this.Keys = 'Keys' in params ? params.Keys : null;
        this.Delimiter = 'Delimiter' in params ? params.Delimiter : null;
        this.EscapeChar = 'EscapeChar' in params ? params.EscapeChar : null;
        this.NonExistingField = 'NonExistingField' in params ? params.NonExistingField : null;

    }
}

/**
 * CreateAlarmNotice request structure.
 * @class
 */
class CreateAlarmNoticeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Notification group name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Notification type. Optional Values:<li> Trigger - Alarm triggered </li><li> Recovery - Alarm recovery</li><li> All - Alarm triggered and alarm recovery</li>
         * @type {string || null}
         */
        this.Type = null;

        /**
         * Notification recipient
         * @type {Array.<NoticeReceiver> || null}
         */
        this.NoticeReceivers = null;

        /**
         * API callback information (including WeCom)
         * @type {Array.<WebCallback> || null}
         */
        this.WebCallbacks = null;

        /**
         * Notification RulesNote: - Type, NoticeReceivers, and WebCallbacks form one set of configurations, and NoticeRules form another set. The two sets of configurations are mutually exclusive.
         * @type {Array.<NoticeRule> || null}
         */
        this.NoticeRules = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Name = 'Name' in params ? params.Name : null;
        this.Type = 'Type' in params ? params.Type : null;

        if (params.NoticeReceivers) {
            this.NoticeReceivers = new Array();
            for (let z in params.NoticeReceivers) {
                let obj = new NoticeReceiver();
                obj.deserialize(params.NoticeReceivers[z]);
                this.NoticeReceivers.push(obj);
            }
        }

        if (params.WebCallbacks) {
            this.WebCallbacks = new Array();
            for (let z in params.WebCallbacks) {
                let obj = new WebCallback();
                obj.deserialize(params.WebCallbacks[z]);
                this.WebCallbacks.push(obj);
            }
        }

        if (params.NoticeRules) {
            this.NoticeRules = new Array();
            for (let z in params.NoticeRules) {
                let obj = new NoticeRule();
                obj.deserialize(params.NoticeRules[z]);
                this.NoticeRules.push(obj);
            }
        }

    }
}

/**
 * DescribeIndex response structure.
 * @class
 */
class DescribeIndexResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Whether it takes effect
         * @type {boolean || null}
         */
        this.Status = null;

        /**
         * Index configuration information
Note: this field may return `null`, indicating that no valid values can be obtained.
         * @type {RuleInfo || null}
         */
        this.Rule = null;

        /**
         * Index modification time. The default value is the index creation time.
         * @type {string || null}
         */
        this.ModifyTime = null;

        /**
         * Whether full-text indexing includes internal fields (`__FILENAME__`, `__HOSTNAME__`, and `__SOURCE__`)
* `false`: Full-text indexing does not include internal fields.
* `true`: Full-text indexing includes internal fields.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.IncludeInternalFields = null;

        /**
         * Whether full-text indexing includes metadata fields (which are prefixed with `__TAG__`)
* `0`: Full-text indexing includes only the metadata fields with key-value indexing enabled.
* `1`: Full-text indexing includes all metadata fields.
* `2`: Full-text indexing does not include metadata fields.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.MetadataFlag = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Status = 'Status' in params ? params.Status : null;

        if (params.Rule) {
            let obj = new RuleInfo();
            obj.deserialize(params.Rule)
            this.Rule = obj;
        }
        this.ModifyTime = 'ModifyTime' in params ? params.ModifyTime : null;
        this.IncludeInternalFields = 'IncludeInternalFields' in params ? params.IncludeInternalFields : null;
        this.MetadataFlag = 'MetadataFlag' in params ? params.MetadataFlag : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Histogram details
 * @class
 */
class HistogramInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * The number of logs within the statistical period
         * @type {number || null}
         */
        this.Count = null;

        /**
         * Unix timestamp rounded by `period`, in milliseconds
         * @type {number || null}
         */
        this.BTime = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Count = 'Count' in params ? params.Count : null;
        this.BTime = 'BTime' in params ? params.BTime : null;

    }
}

/**
 * DescribeMachineGroupConfigs request structure.
 * @class
 */
class DescribeMachineGroupConfigsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Machine group ID
         * @type {string || null}
         */
        this.GroupId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.GroupId = 'GroupId' in params ? params.GroupId : null;

    }
}

/**
 * ModifyKafkaRecharge request structure.
 * @class
 */
class ModifyKafkaRechargeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Kafka data import configuration ID
         * @type {string || null}
         */
        this.Id = null;

        /**
         * Target topic ID
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * Kafka data import configuration name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Kafka type. Valid values: 0 (Tencent Cloud CKafka) and 1 (customer's Kafka)
         * @type {number || null}
         */
        this.KafkaType = null;

        /**
         * CKafka instance ID, which is required when `KafkaType` is set to `0`
         * @type {string || null}
         */
        this.KafkaInstance = null;

        /**
         * Service address
         * @type {string || null}
         */
        this.ServerAddr = null;

        /**
         * Whether the service address uses an encrypted connection
         * @type {boolean || null}
         */
        this.IsEncryptionAddr = null;

        /**
         * Encryption access protocol, which is required when IsEncryptionAddr` is set to `true`
         * @type {KafkaProtocolInfo || null}
         */
        this.Protocol = null;

        /**
         * List of Kafka topics to import data from. Separate multiple topics with commas (,).
         * @type {string || null}
         */
        this.UserKafkaTopics = null;

        /**
         * Kafka consumer group name
         * @type {string || null}
         */
        this.ConsumerGroupName = null;

        /**
         * Log import rule
         * @type {LogRechargeRuleInfo || null}
         */
        this.LogRechargeRule = null;

        /**
         * Import control. Valid values: 1 (suspend) and 2 (resume).
         * @type {number || null}
         */
        this.StatusControl = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Id = 'Id' in params ? params.Id : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.KafkaType = 'KafkaType' in params ? params.KafkaType : null;
        this.KafkaInstance = 'KafkaInstance' in params ? params.KafkaInstance : null;
        this.ServerAddr = 'ServerAddr' in params ? params.ServerAddr : null;
        this.IsEncryptionAddr = 'IsEncryptionAddr' in params ? params.IsEncryptionAddr : null;

        if (params.Protocol) {
            let obj = new KafkaProtocolInfo();
            obj.deserialize(params.Protocol)
            this.Protocol = obj;
        }
        this.UserKafkaTopics = 'UserKafkaTopics' in params ? params.UserKafkaTopics : null;
        this.ConsumerGroupName = 'ConsumerGroupName' in params ? params.ConsumerGroupName : null;

        if (params.LogRechargeRule) {
            let obj = new LogRechargeRuleInfo();
            obj.deserialize(params.LogRechargeRule)
            this.LogRechargeRule = obj;
        }
        this.StatusControl = 'StatusControl' in params ? params.StatusControl : null;

    }
}

/**
 * CreateDataTransform request structure.
 * @class
 */
class CreateDataTransformRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Task type. 1: Specify topic; 2: Dynamic creation. For details, please refer to Creating Processing Task Document (https://intl.cloud.tencent.com/document/product/614/63940?from_cn_redirect=1).
         * @type {number || null}
         */
        this.FuncType = null;

        /**
         * Source log topic
         * @type {string || null}
         */
        this.SrcTopicId = null;

        /**
         * Data processing task name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Data processing statement
         * @type {string || null}
         */
        this.EtlContent = null;

        /**
         * Processing type.
1: Process preview using random data from the source log topic; 2: Process preview using user-defined test data; 3: Create real processing tasks.
         * @type {number || null}
         */
        this.TaskType = null;

        /**
         * Destination topic_id and alias of processing task. This parameter is required when FuncType=1, and not required when FuncType=2.
         * @type {Array.<DataTransformResouceInfo> || null}
         */
        this.DstResources = null;

        /**
         * Task status. Valid values: 1 (enabled) and 2 (disabled).
         * @type {number || null}
         */
        this.EnableFlag = null;

        /**
         * Test data used for previewing the processing result
         * @type {Array.<PreviewLogStatistic> || null}
         */
        this.PreviewLogStatistics = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.FuncType = 'FuncType' in params ? params.FuncType : null;
        this.SrcTopicId = 'SrcTopicId' in params ? params.SrcTopicId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.EtlContent = 'EtlContent' in params ? params.EtlContent : null;
        this.TaskType = 'TaskType' in params ? params.TaskType : null;

        if (params.DstResources) {
            this.DstResources = new Array();
            for (let z in params.DstResources) {
                let obj = new DataTransformResouceInfo();
                obj.deserialize(params.DstResources[z]);
                this.DstResources.push(obj);
            }
        }
        this.EnableFlag = 'EnableFlag' in params ? params.EnableFlag : null;

        if (params.PreviewLogStatistics) {
            this.PreviewLogStatistics = new Array();
            for (let z in params.PreviewLogStatistics) {
                let obj = new PreviewLogStatistic();
                obj.deserialize(params.PreviewLogStatistics[z]);
                this.PreviewLogStatistics.push(obj);
            }
        }

    }
}

/**
 * DeleteMachineGroupInfo response structure.
 * @class
 */
class DeleteMachineGroupInfoResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CheckRechargeKafkaServer response structure.
 * @class
 */
class CheckRechargeKafkaServerResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Kafka cluster accessibility. 0: Accessible.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Status = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Status = 'Status' in params ? params.Status : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * ModifyCosRecharge request structure.
 * @class
 */
class ModifyCosRechargeRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * COS import configuration ID.
         * @type {string || null}
         */
        this.Id = null;

        /**
         * ID of the log topic.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * COS import task name.
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Whether the configuration is enabled. `0`: Not enabled, `1`: Enabled
         * @type {number || null}
         */
        this.Enable = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Id = 'Id' in params ? params.Id : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.Enable = 'Enable' in params ? params.Enable : null;

    }
}

/**
 * DescribeLogsets request structure.
 * @class
 */
class DescribeLogsetsRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * logsetName
- Filter by **logset name**
- Type: String
- Required: No

logsetId
- Filter by **logset ID**
- Type: String
- Required: No

tagKey
- Filter by **tag key**
- Type: String
- Required: No

tag:tagKey
- Filter by **tag key-value pair**. The `tagKey` should be replaced with a specified tag key.
- Type: String
- Required: No

Each request can have up to 10 `Filters` and 5 `Filter.Values`.
         * @type {Array.<Filter> || null}
         */
        this.Filters = null;

        /**
         * Page offset. Default value: 0
         * @type {number || null}
         */
        this.Offset = null;

        /**
         * Maximum number of entries per page. Default value: 20. Maximum value: 100
         * @type {number || null}
         */
        this.Limit = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Filters) {
            this.Filters = new Array();
            for (let z in params.Filters) {
                let obj = new Filter();
                obj.deserialize(params.Filters[z]);
                this.Filters.push(obj);
            }
        }
        this.Offset = 'Offset' in params ? params.Offset : null;
        this.Limit = 'Limit' in params ? params.Limit : null;

    }
}

/**
 * `Parquet` contents
 * @class
 */
class ParquetInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * `ParquetKeyInfo` array
         * @type {Array.<ParquetKeyInfo> || null}
         */
        this.ParquetKeyInfo = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.ParquetKeyInfo) {
            this.ParquetKeyInfo = new Array();
            for (let z in params.ParquetKeyInfo) {
                let obj = new ParquetKeyInfo();
                obj.deserialize(params.ParquetKeyInfo[z]);
                this.ParquetKeyInfo.push(obj);
            }
        }

    }
}

/**
 * DeleteTopic response structure.
 * @class
 */
class DeleteTopicResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * COS import configuration information.
 * @class
 */
class CosRechargeInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * COS import configuration ID.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Id = null;

        /**
         * ID of the log topic.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.TopicId = null;

        /**
         * ID of the logset.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogsetId = null;

        /**
         * COS import task name.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Name = null;

        /**
         * COS bucket.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Bucket = null;

        /**
         * Region where the COS bucket is located.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.BucketRegion = null;

        /**
         * The prefix of the folder where COS files are located.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Prefix = null;

        /**
         * The type of log collected. `json_log`: JSON logs; `delimiter_log`: separator logs; `minimalist_log`: full text in a single line
Default value: `minimalist_log`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.LogType = null;

        /**
         * Status. `0`: Created, `1`: Running, `2`: Stopped, `3`: Completed, `4`: Run failed
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Status = null;

        /**
         * Whether the configuration is enabled. `0`: Not enabled, `1`: Enabled
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Enable = null;

        /**
         * Creation time.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.CreateTime = null;

        /**
         * Update time.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.UpdateTime = null;

        /**
         * Progress in percentage.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.Progress = null;

        /**
         * Valid values: "" (default), "gzip", "lzop", "snappy"
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {string || null}
         */
        this.Compress = null;

        /**
         * See the description of the `ExtractRuleInfo` structure.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {ExtractRuleInfo || null}
         */
        this.ExtractRuleInfo = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Id = 'Id' in params ? params.Id : null;
        this.TopicId = 'TopicId' in params ? params.TopicId : null;
        this.LogsetId = 'LogsetId' in params ? params.LogsetId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.Bucket = 'Bucket' in params ? params.Bucket : null;
        this.BucketRegion = 'BucketRegion' in params ? params.BucketRegion : null;
        this.Prefix = 'Prefix' in params ? params.Prefix : null;
        this.LogType = 'LogType' in params ? params.LogType : null;
        this.Status = 'Status' in params ? params.Status : null;
        this.Enable = 'Enable' in params ? params.Enable : null;
        this.CreateTime = 'CreateTime' in params ? params.CreateTime : null;
        this.UpdateTime = 'UpdateTime' in params ? params.UpdateTime : null;
        this.Progress = 'Progress' in params ? params.Progress : null;
        this.Compress = 'Compress' in params ? params.Compress : null;

        if (params.ExtractRuleInfo) {
            let obj = new ExtractRuleInfo();
            obj.deserialize(params.ExtractRuleInfo)
            this.ExtractRuleInfo = obj;
        }

    }
}

/**
 * Key-Value index configuration
 * @class
 */
class RuleKeyValueInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Case sensitivity
         * @type {boolean || null}
         */
        this.CaseSensitive = null;

        /**
         * Key-value pair information of the index to be created
         * @type {Array.<KeyValueInfo> || null}
         */
        this.KeyValues = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.CaseSensitive = 'CaseSensitive' in params ? params.CaseSensitive : null;

        if (params.KeyValues) {
            this.KeyValues = new Array();
            for (let z in params.KeyValues) {
                let obj = new KeyValueInfo();
                obj.deserialize(params.KeyValues[z]);
                this.KeyValues.push(obj);
            }
        }

    }
}

/**
 * DescribeKafkaConsumer request structure.
 * @class
 */
class DescribeKafkaConsumerRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log Topic ID
         * @type {string || null}
         */
        this.FromTopicId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.FromTopicId = 'FromTopicId' in params ? params.FromTopicId : null;

    }
}

/**
 * ModifyDataTransform response structure.
 * @class
 */
class ModifyDataTransformResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * DescribeDataTransformInfo response structure.
 * @class
 */
class DescribeDataTransformInfoResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * List of data processing tasks
         * @type {Array.<DataTransformTaskInfo> || null}
         */
        this.DataTransformTaskInfos = null;

        /**
         * Total tasks
         * @type {number || null}
         */
        this.TotalCount = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.DataTransformTaskInfos) {
            this.DataTransformTaskInfos = new Array();
            for (let z in params.DataTransformTaskInfos) {
                let obj = new DataTransformTaskInfo();
                obj.deserialize(params.DataTransformTaskInfos[z]);
                this.DataTransformTaskInfos.push(obj);
            }
        }
        this.TotalCount = 'TotalCount' in params ? params.TotalCount : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Shipping content
 * @class
 */
class ConsumerContent extends  AbstractModel {
    constructor(){
        super();

        /**
         * Whether to deliver TAG information.
When EnableTag is true, it indicates the delivery of TAG metadata.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.EnableTag = null;

        /**
         * List of metadata to ship. Supported metadata types: \_\_SOURCE\_\_, \_\_FILENAME\_\_, \_\_TIMESTAMP\_\_, \_\_HOSTNAME\_\_, and \_\_PKGID\_\_.
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {Array.<string> || null}
         */
        this.MetaFields = null;

        /**
         * When EnableTag is true, the TagJsonNotTiled field must be filled.TagJsonNotTiled is used to indicate whether tag information is JSON flattened.When TagJsonNotTiled is true, it is not flattened. Example:TAG information: `{"__TAG__":{"fieldA":200,"fieldB":"text"}}`
Untiled: `{"__TAG__":{"fieldA":200,"fieldB":"text"}}`When TagJsonNotTiled is false, the data is tiled. Example:TAG information: `{"__TAG__":{"fieldA":200,"fieldB":"text"}}`Tiled: `{"__TAG__.fieldA":200,"__TAG__.fieldB":"text"}`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {boolean || null}
         */
        this.TagJsonNotTiled = null;

        /**
         * Delivery timestamp precision, optional [1: second; 2: millisecond], default is 1.Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.TimestampAccuracy = null;

        /**
         * Deliver in JSON format.JsonType is 0: Consistent with the original log, no escape. Example:
Original log: `{"a":"aa", "b":{"b1":"b1b1", "c1":"c1c1"}}`Deliver to CKafka: `{"a":"aa", "b":{"b1":"b1b1", "c1":"c1c1"}}`JsonType is 1: Escaped. Example:Original log: `{"a":"aa", "b":{"b1":"b1b1", "c1":"c1c1"}}`Delivered to CKafka: `{"a":"aa","b":"{\"b1\":\"b1b1\", \"c1\":\"c1c1\"}"}`
Note: This field may return null, indicating that no valid values can be obtained.
         * @type {number || null}
         */
        this.JsonType = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.EnableTag = 'EnableTag' in params ? params.EnableTag : null;
        this.MetaFields = 'MetaFields' in params ? params.MetaFields : null;
        this.TagJsonNotTiled = 'TagJsonNotTiled' in params ? params.TagJsonNotTiled : null;
        this.TimestampAccuracy = 'TimestampAccuracy' in params ? params.TimestampAccuracy : null;
        this.JsonType = 'JsonType' in params ? params.JsonType : null;

    }
}

/**
 * Highlighted Log Description Information
 * @class
 */
class HighLightItem extends  AbstractModel {
    constructor(){
        super();

        /**
         * Highlighted Log Key
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Highlighted Syntax
         * @type {Array.<string> || null}
         */
        this.Values = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Values = 'Values' in params ? params.Values : null;

    }
}

/**
 * RetryShipperTask request structure.
 * @class
 */
class RetryShipperTaskRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Shipping rule ID
         * @type {string || null}
         */
        this.ShipperId = null;

        /**
         * Shipping task ID
         * @type {string || null}
         */
        this.TaskId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ShipperId = 'ShipperId' in params ? params.ShipperId : null;
        this.TaskId = 'TaskId' in params ? params.TaskId : null;

    }
}

/**
 * CreateExport response structure.
 * @class
 */
class CreateExportResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log export ID.
         * @type {string || null}
         */
        this.ExportId = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.ExportId = 'ExportId' in params ? params.ExportId : null;
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * Log keys to be filtered and the corresponding regex
 * @class
 */
class KeyRegexInfo extends  AbstractModel {
    constructor(){
        super();

        /**
         * Log key to be filtered
         * @type {string || null}
         */
        this.Key = null;

        /**
         * Filter rule regex corresponding to key
         * @type {string || null}
         */
        this.Regex = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.Key = 'Key' in params ? params.Key : null;
        this.Regex = 'Regex' in params ? params.Regex : null;

    }
}

/**
 * MergePartition response structure.
 * @class
 */
class MergePartitionResponse extends  AbstractModel {
    constructor(){
        super();

        /**
         * Merge result set
         * @type {Array.<PartitionInfo> || null}
         */
        this.Partitions = null;

        /**
         * The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
         * @type {string || null}
         */
        this.RequestId = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }

        if (params.Partitions) {
            this.Partitions = new Array();
            for (let z in params.Partitions) {
                let obj = new PartitionInfo();
                obj.deserialize(params.Partitions[z]);
                this.Partitions.push(obj);
            }
        }
        this.RequestId = 'RequestId' in params ? params.RequestId : null;

    }
}

/**
 * CreateScheduledSql request structure.
 * @class
 */
class CreateScheduledSqlRequest extends  AbstractModel {
    constructor(){
        super();

        /**
         * Source log topic
         * @type {string || null}
         */
        this.SrcTopicId = null;

        /**
         * Task name
         * @type {string || null}
         */
        this.Name = null;

        /**
         * Task start status. 1: Enabled, 2: Disabled
         * @type {number || null}
         */
        this.EnableFlag = null;

        /**
         * Target log topic for scheduled SQL analysis
         * @type {ScheduledSqlResouceInfo || null}
         */
        this.DstResource = null;

        /**
         * Query statement
         * @type {string || null}
         */
        this.ScheduledSqlContent = null;

        /**
         * Schedule start time, Unix timestamp, in milliseconds
         * @type {number || null}
         */
        this.ProcessStartTime = null;

        /**
         * Schedule type: 1: Continuous running; 2: Specified time range
         * @type {number || null}
         */
        this.ProcessType = null;

        /**
         * Scheduling interval (minutes)
         * @type {number || null}
         */
        this.ProcessPeriod = null;

        /**
         * Time window for a single query. If your target topic is a metric topic, it is recommended that the size of this parameter not exceed 30 minutes, otherwise, metric conversion may fail.
         * @type {string || null}
         */
        this.ProcessTimeWindow = null;

        /**
         * Execution delay (Seconds)
         * @type {number || null}
         */
        this.ProcessDelay = null;

        /**
         * Source topic ID region information
         * @type {string || null}
         */
        this.SrcTopicRegion = null;

        /**
         * Schedule end time. Required field when ProcessType=2, Unix timestamp, in milliseconds
         * @type {number || null}
         */
        this.ProcessEndTime = null;

        /**
         * Query syntax rules. Default value is 0. 0: Lucene syntax, 1: CQL syntax
         * @type {number || null}
         */
        this.SyntaxRule = null;

    }

    /**
     * @private
     */
    deserialize(params) {
        if (!params) {
            return;
        }
        this.SrcTopicId = 'SrcTopicId' in params ? params.SrcTopicId : null;
        this.Name = 'Name' in params ? params.Name : null;
        this.EnableFlag = 'EnableFlag' in params ? params.EnableFlag : null;

        if (params.DstResource) {
            let obj = new ScheduledSqlResouceInfo();
            obj.deserialize(params.DstResource)
            this.DstResource = obj;
        }
        this.ScheduledSqlContent = 'ScheduledSqlContent' in params ? params.ScheduledSqlContent : null;
        this.ProcessStartTime = 'ProcessStartTime' in params ? params.ProcessStartTime : null;
        this.ProcessType = 'ProcessType' in params ? params.ProcessType : null;
        this.ProcessPeriod = 'ProcessPeriod' in params ? params.ProcessPeriod : null;
        this.ProcessTimeWindow = 'ProcessTimeWindow' in params ? params.ProcessTimeWindow : null;
        this.ProcessDelay = 'ProcessDelay' in params ? params.ProcessDelay : null;
        this.SrcTopicRegion = 'SrcTopicRegion' in params ? params.SrcTopicRegion : null;
        this.ProcessEndTime = 'ProcessEndTime' in params ? params.ProcessEndTime : null;
        this.SyntaxRule = 'SyntaxRule' in params ? params.SyntaxRule : null;

    }
}

module.exports = {
    UploadLogResponse: UploadLogResponse,
    CreateAlarmResponse: CreateAlarmResponse,
    AlarmInfo: AlarmInfo,
    LogInfo: LogInfo,
    DeleteAlarmNoticeResponse: DeleteAlarmNoticeResponse,
    DescribeLogHistogramRequest: DescribeLogHistogramRequest,
    DeleteAlarmShieldRequest: DeleteAlarmShieldRequest,
    DescribeLogContextRequest: DescribeLogContextRequest,
    DeleteShipperRequest: DeleteShipperRequest,
    DeleteScheduledSqlRequest: DeleteScheduledSqlRequest,
    DynamicIndex: DynamicIndex,
    DeleteLogsetResponse: DeleteLogsetResponse,
    ParquetKeyInfo: ParquetKeyInfo,
    DescribeCosRechargesResponse: DescribeCosRechargesResponse,
    DescribeShipperTasksResponse: DescribeShipperTasksResponse,
    CheckFunctionRequest: CheckFunctionRequest,
    Filter: Filter,
    DescribeAlarmShieldsResponse: DescribeAlarmShieldsResponse,
    SearchCosRechargeInfoRequest: SearchCosRechargeInfoRequest,
    KafkaRechargeInfo: KafkaRechargeInfo,
    ModifyLogsetRequest: ModifyLogsetRequest,
    UploadLogRequest: UploadLogRequest,
    CreateLogsetRequest: CreateLogsetRequest,
    DescribeShippersRequest: DescribeShippersRequest,
    CreateScheduledSqlResponse: CreateScheduledSqlResponse,
    QueryMetricRequest: QueryMetricRequest,
    LogItem: LogItem,
    SearchLogResponse: SearchLogResponse,
    DeleteTopicRequest: DeleteTopicRequest,
    DescribePartitionsRequest: DescribePartitionsRequest,
    ConfigInfo: ConfigInfo,
    ModifyAlarmResponse: ModifyAlarmResponse,
    DescribeShipperTasksRequest: DescribeShipperTasksRequest,
    DescribeAlarmsRequest: DescribeAlarmsRequest,
    MergePartitionRequest: MergePartitionRequest,
    DescribeShippersResponse: DescribeShippersResponse,
    DescribeKafkaConsumerResponse: DescribeKafkaConsumerResponse,
    ModifyShipperResponse: ModifyShipperResponse,
    DeleteKafkaRechargeResponse: DeleteKafkaRechargeResponse,
    ModifyDataTransformRequest: ModifyDataTransformRequest,
    DescribeScheduledSqlInfoResponse: DescribeScheduledSqlInfoResponse,
    CallBackInfo: CallBackInfo,
    OpenKafkaConsumerResponse: OpenKafkaConsumerResponse,
    AlarmTargetInfo: AlarmTargetInfo,
    AlarmClassification: AlarmClassification,
    ScheduledSqlResouceInfo: ScheduledSqlResouceInfo,
    RetryShipperTaskResponse: RetryShipperTaskResponse,
    DescribeIndexRequest: DescribeIndexRequest,
    ModifyScheduledSqlResponse: ModifyScheduledSqlResponse,
    ConditionInfo: ConditionInfo,
    DeleteMachineGroupInfoRequest: DeleteMachineGroupInfoRequest,
    CreateLogsetResponse: CreateLogsetResponse,
    NoticeRule: NoticeRule,
    DeleteMachineGroupResponse: DeleteMachineGroupResponse,
    KafkaProtocolInfo: KafkaProtocolInfo,
    ScheduledSqlTaskInfo: ScheduledSqlTaskInfo,
    DescribeConfigMachineGroupsRequest: DescribeConfigMachineGroupsRequest,
    MetaTagInfo: MetaTagInfo,
    CreateCosRechargeRequest: CreateCosRechargeRequest,
    DescribeConfigsResponse: DescribeConfigsResponse,
    ExtractRuleInfo: ExtractRuleInfo,
    CreateAlarmShieldResponse: CreateAlarmShieldResponse,
    DeleteDataTransformResponse: DeleteDataTransformResponse,
    ShipperTaskInfo: ShipperTaskInfo,
    ModifyConsumerRequest: ModifyConsumerRequest,
    CreateIndexResponse: CreateIndexResponse,
    DeleteConfigFromMachineGroupResponse: DeleteConfigFromMachineGroupResponse,
    CreateConsumerResponse: CreateConsumerResponse,
    ModifyMachineGroupResponse: ModifyMachineGroupResponse,
    DataTransformResouceInfo: DataTransformResouceInfo,
    DeleteMachineGroupRequest: DeleteMachineGroupRequest,
    FullTextInfo: FullTextInfo,
    QueryMetricResponse: QueryMetricResponse,
    DescribeAlarmShieldsRequest: DescribeAlarmShieldsRequest,
    DescribePartitionsResponse: DescribePartitionsResponse,
    DescribeConfigMachineGroupsResponse: DescribeConfigMachineGroupsResponse,
    ModifyAlarmRequest: ModifyAlarmRequest,
    DescribeTopicsResponse: DescribeTopicsResponse,
    LogItems: LogItems,
    ModifyAlarmNoticeRequest: ModifyAlarmNoticeRequest,
    TopicExtendInfo: TopicExtendInfo,
    EventLog: EventLog,
    CreateAlarmRequest: CreateAlarmRequest,
    DeleteExportResponse: DeleteExportResponse,
    SearchLogInfos: SearchLogInfos,
    PartitionInfo: PartitionInfo,
    DeleteScheduledSqlResponse: DeleteScheduledSqlResponse,
    AlertHistoryRecord: AlertHistoryRecord,
    ExcludePathInfo: ExcludePathInfo,
    FilterRuleInfo: FilterRuleInfo,
    ModifyKafkaConsumerRequest: ModifyKafkaConsumerRequest,
    CreateMachineGroupResponse: CreateMachineGroupResponse,
    SplitPartitionRequest: SplitPartitionRequest,
    CheckRechargeKafkaServerRequest: CheckRechargeKafkaServerRequest,
    CreateAlarmShieldRequest: CreateAlarmShieldRequest,
    MachineGroupInfo: MachineGroupInfo,
    DescribeLogHistogramResponse: DescribeLogHistogramResponse,
    CloseKafkaConsumerResponse: CloseKafkaConsumerResponse,
    DeleteAlarmShieldResponse: DeleteAlarmShieldResponse,
    CreateIndexRequest: CreateIndexRequest,
    DescribeLogsetsResponse: DescribeLogsetsResponse,
    DeleteConsumerResponse: DeleteConsumerResponse,
    DescribeTopicsRequest: DescribeTopicsRequest,
    GetAlarmLogResponse: GetAlarmLogResponse,
    CreateTopicRequest: CreateTopicRequest,
    DescribeExportsRequest: DescribeExportsRequest,
    DescribeMachineGroupsRequest: DescribeMachineGroupsRequest,
    DescribeCosRechargesRequest: DescribeCosRechargesRequest,
    AlarmTarget: AlarmTarget,
    CreateKafkaRechargeResponse: CreateKafkaRechargeResponse,
    ModifyScheduledSqlRequest: ModifyScheduledSqlRequest,
    DeleteConfigResponse: DeleteConfigResponse,
    ModifyAlarmShieldResponse: ModifyAlarmShieldResponse,
    CreateDeliverCloudFunctionRequest: CreateDeliverCloudFunctionRequest,
    DeleteConsumerRequest: DeleteConsumerRequest,
    QueryRangeMetricResponse: QueryRangeMetricResponse,
    DeleteIndexRequest: DeleteIndexRequest,
    AnonymousInfo: AnonymousInfo,
    SearchLogTopics: SearchLogTopics,
    ModifyConsumerResponse: ModifyConsumerResponse,
    DescribeAlertRecordHistoryRequest: DescribeAlertRecordHistoryRequest,
    DescribeConfigsRequest: DescribeConfigsRequest,
    KafkaConsumerContent: KafkaConsumerContent,
    LogsetInfo: LogsetInfo,
    DescribeConsumerRequest: DescribeConsumerRequest,
    DeleteConfigRequest: DeleteConfigRequest,
    AnalysisDimensional: AnalysisDimensional,
    LogRechargeRuleInfo: LogRechargeRuleInfo,
    CloseKafkaConsumerRequest: CloseKafkaConsumerRequest,
    RuleTagInfo: RuleTagInfo,
    CreateExportRequest: CreateExportRequest,
    QueryRangeMetricRequest: QueryRangeMetricRequest,
    DescribeAlarmNoticesResponse: DescribeAlarmNoticesResponse,
    DeleteDataTransformRequest: DeleteDataTransformRequest,
    DescribeMachineGroupsResponse: DescribeMachineGroupsResponse,
    ModifyConfigRequest: ModifyConfigRequest,
    AddMachineGroupInfoRequest: AddMachineGroupInfoRequest,
    DescribeKafkaRechargesRequest: DescribeKafkaRechargesRequest,
    JsonInfo: JsonInfo,
    PreviewKafkaRechargeResponse: PreviewKafkaRechargeResponse,
    CreateShipperRequest: CreateShipperRequest,
    CreateTopicResponse: CreateTopicResponse,
    DeleteAlarmResponse: DeleteAlarmResponse,
    WebCallback: WebCallback,
    DescribeAlarmsResponse: DescribeAlarmsResponse,
    CreateAlarmNoticeResponse: CreateAlarmNoticeResponse,
    ModifyTopicResponse: ModifyTopicResponse,
    CreateConfigRequest: CreateConfigRequest,
    CreateShipperResponse: CreateShipperResponse,
    DescribeKafkaRechargesResponse: DescribeKafkaRechargesResponse,
    DeleteIndexResponse: DeleteIndexResponse,
    AlarmAnalysisConfig: AlarmAnalysisConfig,
    SearchLogErrors: SearchLogErrors,
    ModifyIndexRequest: ModifyIndexRequest,
    Column: Column,
    ContentInfo: ContentInfo,
    ValueInfo: ValueInfo,
    DescribeDataTransformInfoRequest: DescribeDataTransformInfoRequest,
    DeleteShipperResponse: DeleteShipperResponse,
    ExportInfo: ExportInfo,
    ModifyIndexResponse: ModifyIndexResponse,
    TopicInfo: TopicInfo,
    GroupTriggerConditionInfo: GroupTriggerConditionInfo,
    DescribeLogContextResponse: DescribeLogContextResponse,
    CheckFunctionResponse: CheckFunctionResponse,
    DeleteExportRequest: DeleteExportRequest,
    PreviewKafkaRechargeRequest: PreviewKafkaRechargeRequest,
    SplitPartitionResponse: SplitPartitionResponse,
    CreateDataTransformResponse: CreateDataTransformResponse,
    LogContextInfo: LogContextInfo,
    ModifyShipperRequest: ModifyShipperRequest,
    NoticeReceiver: NoticeReceiver,
    CreateKafkaRechargeRequest: CreateKafkaRechargeRequest,
    DeleteKafkaRechargeRequest: DeleteKafkaRechargeRequest,
    RuleInfo: RuleInfo,
    CreateConfigResponse: CreateConfigResponse,
    CreateConsumerRequest: CreateConsumerRequest,
    MultiTopicSearchInformation: MultiTopicSearchInformation,
    AlarmNotice: AlarmNotice,
    ModifyConfigResponse: ModifyConfigResponse,
    OpenKafkaConsumerRequest: OpenKafkaConsumerRequest,
    ModifyKafkaRechargeResponse: ModifyKafkaRechargeResponse,
    ModifyAlarmNoticeResponse: ModifyAlarmNoticeResponse,
    CreateDeliverCloudFunctionResponse: CreateDeliverCloudFunctionResponse,
    DataTransformTaskInfo: DataTransformTaskInfo,
    DescribeMachinesResponse: DescribeMachinesResponse,
    ModifyCosRechargeResponse: ModifyCosRechargeResponse,
    PreviewLogStatistic: PreviewLogStatistic,
    CompressInfo: CompressInfo,
    ApplyConfigToMachineGroupResponse: ApplyConfigToMachineGroupResponse,
    AlertHistoryNotice: AlertHistoryNotice,
    DeleteAlarmRequest: DeleteAlarmRequest,
    AlarmShieldInfo: AlarmShieldInfo,
    ModifyKafkaConsumerResponse: ModifyKafkaConsumerResponse,
    MachineGroupTypeInfo: MachineGroupTypeInfo,
    DeleteConfigFromMachineGroupRequest: DeleteConfigFromMachineGroupRequest,
    SearchCosRechargeInfoResponse: SearchCosRechargeInfoResponse,
    ShipperInfo: ShipperInfo,
    CreateCosRechargeResponse: CreateCosRechargeResponse,
    DescribeAlertRecordHistoryResponse: DescribeAlertRecordHistoryResponse,
    KeyValueInfo: KeyValueInfo,
    AddMachineGroupInfoResponse: AddMachineGroupInfoResponse,
    ModifyMachineGroupRequest: ModifyMachineGroupRequest,
    DescribeAlarmNoticesRequest: DescribeAlarmNoticesRequest,
    DescribeConsumerResponse: DescribeConsumerResponse,
    MetricLabel: MetricLabel,
    ModifyTopicRequest: ModifyTopicRequest,
    Ckafka: Ckafka,
    DescribeMachinesRequest: DescribeMachinesRequest,
    MultiCondition: MultiCondition,
    DeleteAlarmNoticeRequest: DeleteAlarmNoticeRequest,
    DescribeScheduledSqlInfoRequest: DescribeScheduledSqlInfoRequest,
    DeleteLogsetRequest: DeleteLogsetRequest,
    MachineInfo: MachineInfo,
    ModifyLogsetResponse: ModifyLogsetResponse,
    MonitorTime: MonitorTime,
    SearchLogRequest: SearchLogRequest,
    CreateMachineGroupRequest: CreateMachineGroupRequest,
    Tag: Tag,
    ModifyAlarmShieldRequest: ModifyAlarmShieldRequest,
    DescribeExportsResponse: DescribeExportsResponse,
    ApplyConfigToMachineGroupRequest: ApplyConfigToMachineGroupRequest,
    GetAlarmLogRequest: GetAlarmLogRequest,
    DescribeMachineGroupConfigsResponse: DescribeMachineGroupConfigsResponse,
    CsvInfo: CsvInfo,
    CreateAlarmNoticeRequest: CreateAlarmNoticeRequest,
    DescribeIndexResponse: DescribeIndexResponse,
    HistogramInfo: HistogramInfo,
    DescribeMachineGroupConfigsRequest: DescribeMachineGroupConfigsRequest,
    ModifyKafkaRechargeRequest: ModifyKafkaRechargeRequest,
    CreateDataTransformRequest: CreateDataTransformRequest,
    DeleteMachineGroupInfoResponse: DeleteMachineGroupInfoResponse,
    CheckRechargeKafkaServerResponse: CheckRechargeKafkaServerResponse,
    ModifyCosRechargeRequest: ModifyCosRechargeRequest,
    DescribeLogsetsRequest: DescribeLogsetsRequest,
    ParquetInfo: ParquetInfo,
    DeleteTopicResponse: DeleteTopicResponse,
    CosRechargeInfo: CosRechargeInfo,
    RuleKeyValueInfo: RuleKeyValueInfo,
    DescribeKafkaConsumerRequest: DescribeKafkaConsumerRequest,
    ModifyDataTransformResponse: ModifyDataTransformResponse,
    DescribeDataTransformInfoResponse: DescribeDataTransformInfoResponse,
    ConsumerContent: ConsumerContent,
    HighLightItem: HighLightItem,
    RetryShipperTaskRequest: RetryShipperTaskRequest,
    CreateExportResponse: CreateExportResponse,
    KeyRegexInfo: KeyRegexInfo,
    MergePartitionResponse: MergePartitionResponse,
    CreateScheduledSqlRequest: CreateScheduledSqlRequest,

}
